// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: update_metadata.proto

#include "update_metadata.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace chromeos_update_engine {
PROTOBUF_CONSTEXPR Extent::Extent(
    ::_pbi::ConstantInitialized)
  : start_block_(uint64_t{0u})
  , num_blocks_(uint64_t{0u}){}
struct ExtentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExtentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExtentDefaultTypeInternal() {}
  union {
    Extent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExtentDefaultTypeInternal _Extent_default_instance_;
PROTOBUF_CONSTEXPR Signatures_Signature::Signatures_Signature(
    ::_pbi::ConstantInitialized)
  : data_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , version_(0u)
  , unpadded_signature_size_(0u){}
struct Signatures_SignatureDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Signatures_SignatureDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Signatures_SignatureDefaultTypeInternal() {}
  union {
    Signatures_Signature _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Signatures_SignatureDefaultTypeInternal _Signatures_Signature_default_instance_;
PROTOBUF_CONSTEXPR Signatures::Signatures(
    ::_pbi::ConstantInitialized)
  : signatures_(){}
struct SignaturesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SignaturesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SignaturesDefaultTypeInternal() {}
  union {
    Signatures _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SignaturesDefaultTypeInternal _Signatures_default_instance_;
PROTOBUF_CONSTEXPR PartitionInfo::PartitionInfo(
    ::_pbi::ConstantInitialized)
  : hash_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , size_(uint64_t{0u}){}
struct PartitionInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PartitionInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PartitionInfoDefaultTypeInternal() {}
  union {
    PartitionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PartitionInfoDefaultTypeInternal _PartitionInfo_default_instance_;
PROTOBUF_CONSTEXPR InstallOperation::InstallOperation(
    ::_pbi::ConstantInitialized)
  : src_extents_()
  , dst_extents_()
  , data_sha256_hash_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , src_sha256_hash_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , data_offset_(uint64_t{0u})
  , data_length_(uint64_t{0u})
  , src_length_(uint64_t{0u})
  , dst_length_(uint64_t{0u})
  , type_(0)
{}
struct InstallOperationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InstallOperationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InstallOperationDefaultTypeInternal() {}
  union {
    InstallOperation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InstallOperationDefaultTypeInternal _InstallOperation_default_instance_;
PROTOBUF_CONSTEXPR CowMergeOperation::CowMergeOperation(
    ::_pbi::ConstantInitialized)
  : src_extent_(nullptr)
  , dst_extent_(nullptr)
  , type_(0)

  , src_offset_(0u){}
struct CowMergeOperationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CowMergeOperationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CowMergeOperationDefaultTypeInternal() {}
  union {
    CowMergeOperation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CowMergeOperationDefaultTypeInternal _CowMergeOperation_default_instance_;
PROTOBUF_CONSTEXPR PartitionUpdate::PartitionUpdate(
    ::_pbi::ConstantInitialized)
  : new_partition_signature_()
  , operations_()
  , merge_operations_()
  , partition_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , postinstall_path_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , filesystem_type_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , hash_tree_algorithm_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , hash_tree_salt_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , version_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , old_partition_info_(nullptr)
  , new_partition_info_(nullptr)
  , hash_tree_data_extent_(nullptr)
  , hash_tree_extent_(nullptr)
  , fec_data_extent_(nullptr)
  , fec_extent_(nullptr)
  , estimate_cow_size_(uint64_t{0u})
  , estimate_op_count_max_(uint64_t{0u})
  , run_postinstall_(false)
  , postinstall_optional_(false)
  , fec_roots_(2u){}
struct PartitionUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PartitionUpdateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PartitionUpdateDefaultTypeInternal() {}
  union {
    PartitionUpdate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PartitionUpdateDefaultTypeInternal _PartitionUpdate_default_instance_;
PROTOBUF_CONSTEXPR DynamicPartitionGroup::DynamicPartitionGroup(
    ::_pbi::ConstantInitialized)
  : partition_names_()
  , name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , size_(uint64_t{0u}){}
struct DynamicPartitionGroupDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DynamicPartitionGroupDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DynamicPartitionGroupDefaultTypeInternal() {}
  union {
    DynamicPartitionGroup _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DynamicPartitionGroupDefaultTypeInternal _DynamicPartitionGroup_default_instance_;
PROTOBUF_CONSTEXPR VABCFeatureSet::VABCFeatureSet(
    ::_pbi::ConstantInitialized)
  : threaded_(false)
  , batch_writes_(false){}
struct VABCFeatureSetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VABCFeatureSetDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VABCFeatureSetDefaultTypeInternal() {}
  union {
    VABCFeatureSet _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VABCFeatureSetDefaultTypeInternal _VABCFeatureSet_default_instance_;
PROTOBUF_CONSTEXPR DynamicPartitionMetadata::DynamicPartitionMetadata(
    ::_pbi::ConstantInitialized)
  : groups_()
  , vabc_compression_param_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , vabc_feature_set_(nullptr)
  , snapshot_enabled_(false)
  , vabc_enabled_(false)
  , cow_version_(0u)
  , compression_factor_(uint64_t{0u}){}
struct DynamicPartitionMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DynamicPartitionMetadataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DynamicPartitionMetadataDefaultTypeInternal() {}
  union {
    DynamicPartitionMetadata _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DynamicPartitionMetadataDefaultTypeInternal _DynamicPartitionMetadata_default_instance_;
PROTOBUF_CONSTEXPR ApexInfo::ApexInfo(
    ::_pbi::ConstantInitialized)
  : package_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , version_(int64_t{0})
  , decompressed_size_(int64_t{0})
  , is_compressed_(false){}
struct ApexInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ApexInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ApexInfoDefaultTypeInternal() {}
  union {
    ApexInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ApexInfoDefaultTypeInternal _ApexInfo_default_instance_;
PROTOBUF_CONSTEXPR ApexMetadata::ApexMetadata(
    ::_pbi::ConstantInitialized)
  : apex_info_(){}
struct ApexMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ApexMetadataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ApexMetadataDefaultTypeInternal() {}
  union {
    ApexMetadata _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ApexMetadataDefaultTypeInternal _ApexMetadata_default_instance_;
PROTOBUF_CONSTEXPR DeltaArchiveManifest::DeltaArchiveManifest(
    ::_pbi::ConstantInitialized)
  : partitions_()
  , apex_info_()
  , security_patch_level_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , dynamic_partition_metadata_(nullptr)
  , signatures_offset_(uint64_t{0u})
  , signatures_size_(uint64_t{0u})
  , max_timestamp_(int64_t{0})
  , minor_version_(0u)
  , partial_update_(false)
  , block_size_(4096u){}
struct DeltaArchiveManifestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeltaArchiveManifestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeltaArchiveManifestDefaultTypeInternal() {}
  union {
    DeltaArchiveManifest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeltaArchiveManifestDefaultTypeInternal _DeltaArchiveManifest_default_instance_;
}  // namespace chromeos_update_engine
static ::_pb::Metadata file_level_metadata_update_5fmetadata_2eproto[13];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_update_5fmetadata_2eproto[2];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_update_5fmetadata_2eproto = nullptr;

const uint32_t TableStruct_update_5fmetadata_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::Extent, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::Extent, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::Extent, start_block_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::Extent, num_blocks_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::Signatures_Signature, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::Signatures_Signature, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::Signatures_Signature, version_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::Signatures_Signature, data_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::Signatures_Signature, unpadded_signature_size_),
  1,
  0,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::Signatures, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::Signatures, signatures_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionInfo, size_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionInfo, hash_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::InstallOperation, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::InstallOperation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::InstallOperation, type_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::InstallOperation, data_offset_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::InstallOperation, data_length_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::InstallOperation, src_extents_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::InstallOperation, src_length_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::InstallOperation, dst_extents_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::InstallOperation, dst_length_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::InstallOperation, data_sha256_hash_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::InstallOperation, src_sha256_hash_),
  6,
  2,
  3,
  ~0u,
  4,
  ~0u,
  5,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::CowMergeOperation, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::CowMergeOperation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::CowMergeOperation, type_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::CowMergeOperation, src_extent_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::CowMergeOperation, dst_extent_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::CowMergeOperation, src_offset_),
  2,
  0,
  1,
  3,
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, partition_name_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, run_postinstall_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, postinstall_path_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, filesystem_type_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, new_partition_signature_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, old_partition_info_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, new_partition_info_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, operations_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, postinstall_optional_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, hash_tree_data_extent_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, hash_tree_extent_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, hash_tree_algorithm_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, hash_tree_salt_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, fec_data_extent_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, fec_extent_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, fec_roots_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, version_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, merge_operations_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, estimate_cow_size_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, estimate_op_count_max_),
  0,
  14,
  1,
  2,
  ~0u,
  6,
  7,
  ~0u,
  15,
  8,
  9,
  3,
  4,
  10,
  11,
  16,
  5,
  ~0u,
  12,
  13,
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DynamicPartitionGroup, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DynamicPartitionGroup, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DynamicPartitionGroup, name_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DynamicPartitionGroup, size_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DynamicPartitionGroup, partition_names_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::VABCFeatureSet, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::VABCFeatureSet, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::VABCFeatureSet, threaded_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::VABCFeatureSet, batch_writes_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DynamicPartitionMetadata, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DynamicPartitionMetadata, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DynamicPartitionMetadata, groups_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DynamicPartitionMetadata, snapshot_enabled_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DynamicPartitionMetadata, vabc_enabled_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DynamicPartitionMetadata, vabc_compression_param_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DynamicPartitionMetadata, cow_version_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DynamicPartitionMetadata, vabc_feature_set_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DynamicPartitionMetadata, compression_factor_),
  ~0u,
  2,
  3,
  0,
  4,
  1,
  5,
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::ApexInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::ApexInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::ApexInfo, package_name_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::ApexInfo, version_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::ApexInfo, is_compressed_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::ApexInfo, decompressed_size_),
  0,
  1,
  3,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::ApexMetadata, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::ApexMetadata, apex_info_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DeltaArchiveManifest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DeltaArchiveManifest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DeltaArchiveManifest, block_size_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DeltaArchiveManifest, signatures_offset_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DeltaArchiveManifest, signatures_size_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DeltaArchiveManifest, minor_version_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DeltaArchiveManifest, partitions_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DeltaArchiveManifest, max_timestamp_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DeltaArchiveManifest, dynamic_partition_metadata_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DeltaArchiveManifest, partial_update_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DeltaArchiveManifest, apex_info_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DeltaArchiveManifest, security_patch_level_),
  7,
  2,
  3,
  5,
  ~0u,
  4,
  1,
  6,
  ~0u,
  0,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::chromeos_update_engine::Extent)},
  { 10, 19, -1, sizeof(::chromeos_update_engine::Signatures_Signature)},
  { 22, -1, -1, sizeof(::chromeos_update_engine::Signatures)},
  { 29, 37, -1, sizeof(::chromeos_update_engine::PartitionInfo)},
  { 39, 54, -1, sizeof(::chromeos_update_engine::InstallOperation)},
  { 63, 73, -1, sizeof(::chromeos_update_engine::CowMergeOperation)},
  { 77, 103, -1, sizeof(::chromeos_update_engine::PartitionUpdate)},
  { 123, 132, -1, sizeof(::chromeos_update_engine::DynamicPartitionGroup)},
  { 135, 143, -1, sizeof(::chromeos_update_engine::VABCFeatureSet)},
  { 145, 158, -1, sizeof(::chromeos_update_engine::DynamicPartitionMetadata)},
  { 165, 175, -1, sizeof(::chromeos_update_engine::ApexInfo)},
  { 179, -1, -1, sizeof(::chromeos_update_engine::ApexMetadata)},
  { 186, 202, -1, sizeof(::chromeos_update_engine::DeltaArchiveManifest)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::chromeos_update_engine::_Extent_default_instance_._instance,
  &::chromeos_update_engine::_Signatures_Signature_default_instance_._instance,
  &::chromeos_update_engine::_Signatures_default_instance_._instance,
  &::chromeos_update_engine::_PartitionInfo_default_instance_._instance,
  &::chromeos_update_engine::_InstallOperation_default_instance_._instance,
  &::chromeos_update_engine::_CowMergeOperation_default_instance_._instance,
  &::chromeos_update_engine::_PartitionUpdate_default_instance_._instance,
  &::chromeos_update_engine::_DynamicPartitionGroup_default_instance_._instance,
  &::chromeos_update_engine::_VABCFeatureSet_default_instance_._instance,
  &::chromeos_update_engine::_DynamicPartitionMetadata_default_instance_._instance,
  &::chromeos_update_engine::_ApexInfo_default_instance_._instance,
  &::chromeos_update_engine::_ApexMetadata_default_instance_._instance,
  &::chromeos_update_engine::_DeltaArchiveManifest_default_instance_._instance,
};

const char descriptor_table_protodef_update_5fmetadata_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\025update_metadata.proto\022\026chromeos_update"
  "_engine\"1\n\006Extent\022\023\n\013start_block\030\001 \001(\004\022\022"
  "\n\nnum_blocks\030\002 \001(\004\"\237\001\n\nSignatures\022@\n\nsig"
  "natures\030\001 \003(\0132,.chromeos_update_engine.S"
  "ignatures.Signature\032O\n\tSignature\022\023\n\007vers"
  "ion\030\001 \001(\rB\002\030\001\022\014\n\004data\030\002 \001(\014\022\037\n\027unpadded_"
  "signature_size\030\003 \001(\007\"+\n\rPartitionInfo\022\014\n"
  "\004size\030\001 \001(\004\022\014\n\004hash\030\002 \001(\014\"\246\004\n\020InstallOpe"
  "ration\022;\n\004type\030\001 \002(\0162-.chromeos_update_e"
  "ngine.InstallOperation.Type\022\023\n\013data_offs"
  "et\030\002 \001(\004\022\023\n\013data_length\030\003 \001(\004\0223\n\013src_ext"
  "ents\030\004 \003(\0132\036.chromeos_update_engine.Exte"
  "nt\022\022\n\nsrc_length\030\005 \001(\004\0223\n\013dst_extents\030\006 "
  "\003(\0132\036.chromeos_update_engine.Extent\022\022\n\nd"
  "st_length\030\007 \001(\004\022\030\n\020data_sha256_hash\030\010 \001("
  "\014\022\027\n\017src_sha256_hash\030\t \001(\014\"\345\001\n\004Type\022\013\n\007R"
  "EPLACE\020\000\022\016\n\nREPLACE_BZ\020\001\022\014\n\004MOVE\020\002\032\002\010\001\022\016"
  "\n\006BSDIFF\020\003\032\002\010\001\022\017\n\013SOURCE_COPY\020\004\022\021\n\rSOURC"
  "E_BSDIFF\020\005\022\016\n\nREPLACE_XZ\020\010\022\010\n\004ZERO\020\006\022\013\n\007"
  "DISCARD\020\007\022\021\n\rBROTLI_BSDIFF\020\n\022\014\n\010PUFFDIFF"
  "\020\t\022\014\n\010ZUCCHINI\020\013\022\022\n\016LZ4DIFF_BSDIFF\020\014\022\024\n\020"
  "LZ4DIFF_PUFFDIFF\020\r\"\201\002\n\021CowMergeOperation"
  "\022<\n\004type\030\001 \001(\0162..chromeos_update_engine."
  "CowMergeOperation.Type\0222\n\nsrc_extent\030\002 \001"
  "(\0132\036.chromeos_update_engine.Extent\0222\n\nds"
  "t_extent\030\003 \001(\0132\036.chromeos_update_engine."
  "Extent\022\022\n\nsrc_offset\030\004 \001(\r\"2\n\004Type\022\014\n\010CO"
  "W_COPY\020\000\022\013\n\007COW_XOR\020\001\022\017\n\013COW_REPLACE\020\002\"\347"
  "\006\n\017PartitionUpdate\022\026\n\016partition_name\030\001 \002"
  "(\t\022\027\n\017run_postinstall\030\002 \001(\010\022\030\n\020postinsta"
  "ll_path\030\003 \001(\t\022\027\n\017filesystem_type\030\004 \001(\t\022M"
  "\n\027new_partition_signature\030\005 \003(\0132,.chrome"
  "os_update_engine.Signatures.Signature\022A\n"
  "\022old_partition_info\030\006 \001(\0132%.chromeos_upd"
  "ate_engine.PartitionInfo\022A\n\022new_partitio"
  "n_info\030\007 \001(\0132%.chromeos_update_engine.Pa"
  "rtitionInfo\022<\n\noperations\030\010 \003(\0132(.chrome"
  "os_update_engine.InstallOperation\022\034\n\024pos"
  "tinstall_optional\030\t \001(\010\022=\n\025hash_tree_dat"
  "a_extent\030\n \001(\0132\036.chromeos_update_engine."
  "Extent\0228\n\020hash_tree_extent\030\013 \001(\0132\036.chrom"
  "eos_update_engine.Extent\022\033\n\023hash_tree_al"
  "gorithm\030\014 \001(\t\022\026\n\016hash_tree_salt\030\r \001(\014\0227\n"
  "\017fec_data_extent\030\016 \001(\0132\036.chromeos_update"
  "_engine.Extent\0222\n\nfec_extent\030\017 \001(\0132\036.chr"
  "omeos_update_engine.Extent\022\024\n\tfec_roots\030"
  "\020 \001(\r:\0012\022\017\n\007version\030\021 \001(\t\022C\n\020merge_opera"
  "tions\030\022 \003(\0132).chromeos_update_engine.Cow"
  "MergeOperation\022\031\n\021estimate_cow_size\030\023 \001("
  "\004\022\035\n\025estimate_op_count_max\030\024 \001(\004\"L\n\025Dyna"
  "micPartitionGroup\022\014\n\004name\030\001 \002(\t\022\014\n\004size\030"
  "\002 \001(\004\022\027\n\017partition_names\030\003 \003(\t\"8\n\016VABCFe"
  "atureSet\022\020\n\010threaded\030\001 \001(\010\022\024\n\014batch_writ"
  "es\030\002 \001(\010\"\234\002\n\030DynamicPartitionMetadata\022=\n"
  "\006groups\030\001 \003(\0132-.chromeos_update_engine.D"
  "ynamicPartitionGroup\022\030\n\020snapshot_enabled"
  "\030\002 \001(\010\022\024\n\014vabc_enabled\030\003 \001(\010\022\036\n\026vabc_com"
  "pression_param\030\004 \001(\t\022\023\n\013cow_version\030\005 \001("
  "\r\022@\n\020vabc_feature_set\030\006 \001(\0132&.chromeos_u"
  "pdate_engine.VABCFeatureSet\022\032\n\022compressi"
  "on_factor\030\007 \001(\004\"c\n\010ApexInfo\022\024\n\014package_n"
  "ame\030\001 \001(\t\022\017\n\007version\030\002 \001(\003\022\025\n\ris_compres"
  "sed\030\003 \001(\010\022\031\n\021decompressed_size\030\004 \001(\003\"C\n\014"
  "ApexMetadata\0223\n\tapex_info\030\001 \003(\0132 .chrome"
  "os_update_engine.ApexInfo\"\303\003\n\024DeltaArchi"
  "veManifest\022\030\n\nblock_size\030\003 \001(\r:\0044096\022\031\n\021"
  "signatures_offset\030\004 \001(\004\022\027\n\017signatures_si"
  "ze\030\005 \001(\004\022\030\n\rminor_version\030\014 \001(\r:\0010\022;\n\npa"
  "rtitions\030\r \003(\0132\'.chromeos_update_engine."
  "PartitionUpdate\022\025\n\rmax_timestamp\030\016 \001(\003\022T"
  "\n\032dynamic_partition_metadata\030\017 \001(\01320.chr"
  "omeos_update_engine.DynamicPartitionMeta"
  "data\022\026\n\016partial_update\030\020 \001(\010\0223\n\tapex_inf"
  "o\030\021 \003(\0132 .chromeos_update_engine.ApexInf"
  "o\022\034\n\024security_patch_level\030\022 \001(\tJ\004\010\001\020\002J\004\010"
  "\002\020\003J\004\010\006\020\007J\004\010\007\020\010J\004\010\010\020\tJ\004\010\t\020\nJ\004\010\n\020\013J\004\010\013\020\014"
  ;
static ::_pbi::once_flag descriptor_table_update_5fmetadata_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_update_5fmetadata_2eproto = {
    false, false, 3039, descriptor_table_protodef_update_5fmetadata_2eproto,
    "update_metadata.proto",
    &descriptor_table_update_5fmetadata_2eproto_once, nullptr, 0, 13,
    schemas, file_default_instances, TableStruct_update_5fmetadata_2eproto::offsets,
    file_level_metadata_update_5fmetadata_2eproto, file_level_enum_descriptors_update_5fmetadata_2eproto,
    file_level_service_descriptors_update_5fmetadata_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_update_5fmetadata_2eproto_getter() {
  return &descriptor_table_update_5fmetadata_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_update_5fmetadata_2eproto(&descriptor_table_update_5fmetadata_2eproto);
namespace chromeos_update_engine {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InstallOperation_Type_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_update_5fmetadata_2eproto);
  return file_level_enum_descriptors_update_5fmetadata_2eproto[0];
}
bool InstallOperation_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr InstallOperation_Type InstallOperation::REPLACE;
constexpr InstallOperation_Type InstallOperation::REPLACE_BZ;
constexpr InstallOperation_Type InstallOperation::MOVE;
constexpr InstallOperation_Type InstallOperation::BSDIFF;
constexpr InstallOperation_Type InstallOperation::SOURCE_COPY;
constexpr InstallOperation_Type InstallOperation::SOURCE_BSDIFF;
constexpr InstallOperation_Type InstallOperation::REPLACE_XZ;
constexpr InstallOperation_Type InstallOperation::ZERO;
constexpr InstallOperation_Type InstallOperation::DISCARD;
constexpr InstallOperation_Type InstallOperation::BROTLI_BSDIFF;
constexpr InstallOperation_Type InstallOperation::PUFFDIFF;
constexpr InstallOperation_Type InstallOperation::ZUCCHINI;
constexpr InstallOperation_Type InstallOperation::LZ4DIFF_BSDIFF;
constexpr InstallOperation_Type InstallOperation::LZ4DIFF_PUFFDIFF;
constexpr InstallOperation_Type InstallOperation::Type_MIN;
constexpr InstallOperation_Type InstallOperation::Type_MAX;
constexpr int InstallOperation::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CowMergeOperation_Type_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_update_5fmetadata_2eproto);
  return file_level_enum_descriptors_update_5fmetadata_2eproto[1];
}
bool CowMergeOperation_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CowMergeOperation_Type CowMergeOperation::COW_COPY;
constexpr CowMergeOperation_Type CowMergeOperation::COW_XOR;
constexpr CowMergeOperation_Type CowMergeOperation::COW_REPLACE;
constexpr CowMergeOperation_Type CowMergeOperation::Type_MIN;
constexpr CowMergeOperation_Type CowMergeOperation::Type_MAX;
constexpr int CowMergeOperation::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class Extent::_Internal {
 public:
  using HasBits = decltype(std::declval<Extent>()._has_bits_);
  static void set_has_start_block(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Extent::Extent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:chromeos_update_engine.Extent)
}
Extent::Extent(const Extent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&start_block_, &from.start_block_,
    static_cast<size_t>(reinterpret_cast<char*>(&num_blocks_) -
    reinterpret_cast<char*>(&start_block_)) + sizeof(num_blocks_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.Extent)
}

inline void Extent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&start_block_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&num_blocks_) -
    reinterpret_cast<char*>(&start_block_)) + sizeof(num_blocks_));
}

Extent::~Extent() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.Extent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Extent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Extent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Extent::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.Extent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&start_block_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&num_blocks_) -
        reinterpret_cast<char*>(&start_block_)) + sizeof(num_blocks_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Extent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 start_block = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_start_block(&has_bits);
          start_block_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 num_blocks = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_num_blocks(&has_bits);
          num_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Extent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chromeos_update_engine.Extent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 start_block = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_start_block(), target);
  }

  // optional uint64 num_blocks = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_num_blocks(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chromeos_update_engine.Extent)
  return target;
}

size_t Extent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.Extent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 start_block = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_start_block());
    }

    // optional uint64 num_blocks = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_num_blocks());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Extent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Extent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Extent::GetClassData() const { return &_class_data_; }

void Extent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Extent *>(to)->MergeFrom(
      static_cast<const Extent &>(from));
}


void Extent::MergeFrom(const Extent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.Extent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      start_block_ = from.start_block_;
    }
    if (cached_has_bits & 0x00000002u) {
      num_blocks_ = from.num_blocks_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Extent::CopyFrom(const Extent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.Extent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Extent::IsInitialized() const {
  return true;
}

void Extent::InternalSwap(Extent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Extent, num_blocks_)
      + sizeof(Extent::num_blocks_)
      - PROTOBUF_FIELD_OFFSET(Extent, start_block_)>(
          reinterpret_cast<char*>(&start_block_),
          reinterpret_cast<char*>(&other->start_block_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Extent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_update_5fmetadata_2eproto_getter, &descriptor_table_update_5fmetadata_2eproto_once,
      file_level_metadata_update_5fmetadata_2eproto[0]);
}

// ===================================================================

class Signatures_Signature::_Internal {
 public:
  using HasBits = decltype(std::declval<Signatures_Signature>()._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_unpadded_signature_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Signatures_Signature::Signatures_Signature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:chromeos_update_engine.Signatures.Signature)
}
Signatures_Signature::Signatures_Signature(const Signatures_Signature& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data()) {
    data_.Set(from._internal_data(), 
      GetArenaForAllocation());
  }
  ::memcpy(&version_, &from.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&unpadded_signature_size_) -
    reinterpret_cast<char*>(&version_)) + sizeof(unpadded_signature_size_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.Signatures.Signature)
}

inline void Signatures_Signature::SharedCtor() {
data_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  data_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&version_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&unpadded_signature_size_) -
    reinterpret_cast<char*>(&version_)) + sizeof(unpadded_signature_size_));
}

Signatures_Signature::~Signatures_Signature() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.Signatures.Signature)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Signatures_Signature::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  data_.Destroy();
}

void Signatures_Signature::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Signatures_Signature::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.Signatures.Signature)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&unpadded_signature_size_) -
        reinterpret_cast<char*>(&version_)) + sizeof(unpadded_signature_size_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Signatures_Signature::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 version = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 unpadded_signature_size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_unpadded_signature_size(&has_bits);
          unpadded_signature_size_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Signatures_Signature::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chromeos_update_engine.Signatures.Signature)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 version = 1 [deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_version(), target);
  }

  // optional bytes data = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_data(), target);
  }

  // optional fixed32 unpadded_signature_size = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(3, this->_internal_unpadded_signature_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chromeos_update_engine.Signatures.Signature)
  return target;
}

size_t Signatures_Signature::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.Signatures.Signature)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes data = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data());
    }

    // optional uint32 version = 1 [deprecated = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_version());
    }

    // optional fixed32 unpadded_signature_size = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Signatures_Signature::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Signatures_Signature::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Signatures_Signature::GetClassData() const { return &_class_data_; }

void Signatures_Signature::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Signatures_Signature *>(to)->MergeFrom(
      static_cast<const Signatures_Signature &>(from));
}


void Signatures_Signature::MergeFrom(const Signatures_Signature& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.Signatures.Signature)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000002u) {
      version_ = from.version_;
    }
    if (cached_has_bits & 0x00000004u) {
      unpadded_signature_size_ = from.unpadded_signature_size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Signatures_Signature::CopyFrom(const Signatures_Signature& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.Signatures.Signature)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Signatures_Signature::IsInitialized() const {
  return true;
}

void Signatures_Signature::InternalSwap(Signatures_Signature* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &data_, lhs_arena,
      &other->data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Signatures_Signature, unpadded_signature_size_)
      + sizeof(Signatures_Signature::unpadded_signature_size_)
      - PROTOBUF_FIELD_OFFSET(Signatures_Signature, version_)>(
          reinterpret_cast<char*>(&version_),
          reinterpret_cast<char*>(&other->version_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Signatures_Signature::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_update_5fmetadata_2eproto_getter, &descriptor_table_update_5fmetadata_2eproto_once,
      file_level_metadata_update_5fmetadata_2eproto[1]);
}

// ===================================================================

class Signatures::_Internal {
 public:
};

Signatures::Signatures(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  signatures_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:chromeos_update_engine.Signatures)
}
Signatures::Signatures(const Signatures& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      signatures_(from.signatures_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.Signatures)
}

inline void Signatures::SharedCtor() {
}

Signatures::~Signatures() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.Signatures)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Signatures::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Signatures::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Signatures::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.Signatures)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  signatures_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Signatures::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .chromeos_update_engine.Signatures.Signature signatures = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_signatures(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Signatures::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chromeos_update_engine.Signatures)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.Signatures.Signature signatures = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_signatures_size()); i < n; i++) {
    const auto& repfield = this->_internal_signatures(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chromeos_update_engine.Signatures)
  return target;
}

size_t Signatures::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.Signatures)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.Signatures.Signature signatures = 1;
  total_size += 1UL * this->_internal_signatures_size();
  for (const auto& msg : this->signatures_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Signatures::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Signatures::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Signatures::GetClassData() const { return &_class_data_; }

void Signatures::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Signatures *>(to)->MergeFrom(
      static_cast<const Signatures &>(from));
}


void Signatures::MergeFrom(const Signatures& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.Signatures)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  signatures_.MergeFrom(from.signatures_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Signatures::CopyFrom(const Signatures& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.Signatures)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Signatures::IsInitialized() const {
  return true;
}

void Signatures::InternalSwap(Signatures* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  signatures_.InternalSwap(&other->signatures_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Signatures::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_update_5fmetadata_2eproto_getter, &descriptor_table_update_5fmetadata_2eproto_once,
      file_level_metadata_update_5fmetadata_2eproto[2]);
}

// ===================================================================

class PartitionInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<PartitionInfo>()._has_bits_);
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PartitionInfo::PartitionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:chromeos_update_engine.PartitionInfo)
}
PartitionInfo::PartitionInfo(const PartitionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hash()) {
    hash_.Set(from._internal_hash(), 
      GetArenaForAllocation());
  }
  size_ = from.size_;
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.PartitionInfo)
}

inline void PartitionInfo::SharedCtor() {
hash_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  hash_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
size_ = uint64_t{0u};
}

PartitionInfo::~PartitionInfo() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.PartitionInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PartitionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  hash_.Destroy();
}

void PartitionInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PartitionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.PartitionInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    hash_.ClearNonDefaultToEmpty();
  }
  size_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PartitionInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_size(&has_bits);
          size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PartitionInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chromeos_update_engine.PartitionInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 size = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_size(), target);
  }

  // optional bytes hash = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chromeos_update_engine.PartitionInfo)
  return target;
}

size_t PartitionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.PartitionInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes hash = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_hash());
    }

    // optional uint64 size = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_size());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PartitionInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PartitionInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PartitionInfo::GetClassData() const { return &_class_data_; }

void PartitionInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PartitionInfo *>(to)->MergeFrom(
      static_cast<const PartitionInfo &>(from));
}


void PartitionInfo::MergeFrom(const PartitionInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.PartitionInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_hash(from._internal_hash());
    }
    if (cached_has_bits & 0x00000002u) {
      size_ = from.size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PartitionInfo::CopyFrom(const PartitionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.PartitionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PartitionInfo::IsInitialized() const {
  return true;
}

void PartitionInfo::InternalSwap(PartitionInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &hash_, lhs_arena,
      &other->hash_, rhs_arena
  );
  swap(size_, other->size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PartitionInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_update_5fmetadata_2eproto_getter, &descriptor_table_update_5fmetadata_2eproto_once,
      file_level_metadata_update_5fmetadata_2eproto[3]);
}

// ===================================================================

class InstallOperation::_Internal {
 public:
  using HasBits = decltype(std::declval<InstallOperation>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_data_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_data_length(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_src_length(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_dst_length(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_data_sha256_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_src_sha256_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000040) ^ 0x00000040) != 0;
  }
};

InstallOperation::InstallOperation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  src_extents_(arena),
  dst_extents_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:chromeos_update_engine.InstallOperation)
}
InstallOperation::InstallOperation(const InstallOperation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      src_extents_(from.src_extents_),
      dst_extents_(from.dst_extents_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  data_sha256_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    data_sha256_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data_sha256_hash()) {
    data_sha256_hash_.Set(from._internal_data_sha256_hash(), 
      GetArenaForAllocation());
  }
  src_sha256_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    src_sha256_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_src_sha256_hash()) {
    src_sha256_hash_.Set(from._internal_src_sha256_hash(), 
      GetArenaForAllocation());
  }
  ::memcpy(&data_offset_, &from.data_offset_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&data_offset_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.InstallOperation)
}

inline void InstallOperation::SharedCtor() {
data_sha256_hash_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  data_sha256_hash_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
src_sha256_hash_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  src_sha256_hash_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&data_offset_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&data_offset_)) + sizeof(type_));
}

InstallOperation::~InstallOperation() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.InstallOperation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InstallOperation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  data_sha256_hash_.Destroy();
  src_sha256_hash_.Destroy();
}

void InstallOperation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void InstallOperation::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.InstallOperation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  src_extents_.Clear();
  dst_extents_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      data_sha256_hash_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      src_sha256_hash_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000007cu) {
    ::memset(&data_offset_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&type_) -
        reinterpret_cast<char*>(&data_offset_)) + sizeof(type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InstallOperation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .chromeos_update_engine.InstallOperation.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::chromeos_update_engine::InstallOperation_Type_IsValid(val))) {
            _internal_set_type(static_cast<::chromeos_update_engine::InstallOperation_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint64 data_offset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_data_offset(&has_bits);
          data_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 data_length = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_data_length(&has_bits);
          data_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .chromeos_update_engine.Extent src_extents = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_src_extents(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 src_length = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_src_length(&has_bits);
          src_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .chromeos_update_engine.Extent dst_extents = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_dst_extents(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 dst_length = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_dst_length(&has_bits);
          dst_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes data_sha256_hash = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_data_sha256_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes src_sha256_hash = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_src_sha256_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InstallOperation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chromeos_update_engine.InstallOperation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .chromeos_update_engine.InstallOperation.Type type = 1;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional uint64 data_offset = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_data_offset(), target);
  }

  // optional uint64 data_length = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_data_length(), target);
  }

  // repeated .chromeos_update_engine.Extent src_extents = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_src_extents_size()); i < n; i++) {
    const auto& repfield = this->_internal_src_extents(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint64 src_length = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_src_length(), target);
  }

  // repeated .chromeos_update_engine.Extent dst_extents = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_dst_extents_size()); i < n; i++) {
    const auto& repfield = this->_internal_dst_extents(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint64 dst_length = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_dst_length(), target);
  }

  // optional bytes data_sha256_hash = 8;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_data_sha256_hash(), target);
  }

  // optional bytes src_sha256_hash = 9;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        9, this->_internal_src_sha256_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chromeos_update_engine.InstallOperation)
  return target;
}

size_t InstallOperation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.InstallOperation)
  size_t total_size = 0;

  // required .chromeos_update_engine.InstallOperation.Type type = 1;
  if (_internal_has_type()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.Extent src_extents = 4;
  total_size += 1UL * this->_internal_src_extents_size();
  for (const auto& msg : this->src_extents_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .chromeos_update_engine.Extent dst_extents = 6;
  total_size += 1UL * this->_internal_dst_extents_size();
  for (const auto& msg : this->dst_extents_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional bytes data_sha256_hash = 8;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data_sha256_hash());
    }

    // optional bytes src_sha256_hash = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_src_sha256_hash());
    }

    // optional uint64 data_offset = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_data_offset());
    }

    // optional uint64 data_length = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_data_length());
    }

    // optional uint64 src_length = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_src_length());
    }

    // optional uint64 dst_length = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dst_length());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InstallOperation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    InstallOperation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InstallOperation::GetClassData() const { return &_class_data_; }

void InstallOperation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<InstallOperation *>(to)->MergeFrom(
      static_cast<const InstallOperation &>(from));
}


void InstallOperation::MergeFrom(const InstallOperation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.InstallOperation)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  src_extents_.MergeFrom(from.src_extents_);
  dst_extents_.MergeFrom(from.dst_extents_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_data_sha256_hash(from._internal_data_sha256_hash());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_src_sha256_hash(from._internal_src_sha256_hash());
    }
    if (cached_has_bits & 0x00000004u) {
      data_offset_ = from.data_offset_;
    }
    if (cached_has_bits & 0x00000008u) {
      data_length_ = from.data_length_;
    }
    if (cached_has_bits & 0x00000010u) {
      src_length_ = from.src_length_;
    }
    if (cached_has_bits & 0x00000020u) {
      dst_length_ = from.dst_length_;
    }
    if (cached_has_bits & 0x00000040u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InstallOperation::CopyFrom(const InstallOperation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.InstallOperation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InstallOperation::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void InstallOperation::InternalSwap(InstallOperation* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  src_extents_.InternalSwap(&other->src_extents_);
  dst_extents_.InternalSwap(&other->dst_extents_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &data_sha256_hash_, lhs_arena,
      &other->data_sha256_hash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &src_sha256_hash_, lhs_arena,
      &other->src_sha256_hash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InstallOperation, type_)
      + sizeof(InstallOperation::type_)
      - PROTOBUF_FIELD_OFFSET(InstallOperation, data_offset_)>(
          reinterpret_cast<char*>(&data_offset_),
          reinterpret_cast<char*>(&other->data_offset_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InstallOperation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_update_5fmetadata_2eproto_getter, &descriptor_table_update_5fmetadata_2eproto_once,
      file_level_metadata_update_5fmetadata_2eproto[4]);
}

// ===================================================================

class CowMergeOperation::_Internal {
 public:
  using HasBits = decltype(std::declval<CowMergeOperation>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::chromeos_update_engine::Extent& src_extent(const CowMergeOperation* msg);
  static void set_has_src_extent(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::chromeos_update_engine::Extent& dst_extent(const CowMergeOperation* msg);
  static void set_has_dst_extent(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_src_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::chromeos_update_engine::Extent&
CowMergeOperation::_Internal::src_extent(const CowMergeOperation* msg) {
  return *msg->src_extent_;
}
const ::chromeos_update_engine::Extent&
CowMergeOperation::_Internal::dst_extent(const CowMergeOperation* msg) {
  return *msg->dst_extent_;
}
CowMergeOperation::CowMergeOperation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:chromeos_update_engine.CowMergeOperation)
}
CowMergeOperation::CowMergeOperation(const CowMergeOperation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_src_extent()) {
    src_extent_ = new ::chromeos_update_engine::Extent(*from.src_extent_);
  } else {
    src_extent_ = nullptr;
  }
  if (from._internal_has_dst_extent()) {
    dst_extent_ = new ::chromeos_update_engine::Extent(*from.dst_extent_);
  } else {
    dst_extent_ = nullptr;
  }
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&src_offset_) -
    reinterpret_cast<char*>(&type_)) + sizeof(src_offset_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.CowMergeOperation)
}

inline void CowMergeOperation::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&src_extent_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&src_offset_) -
    reinterpret_cast<char*>(&src_extent_)) + sizeof(src_offset_));
}

CowMergeOperation::~CowMergeOperation() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.CowMergeOperation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CowMergeOperation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete src_extent_;
  if (this != internal_default_instance()) delete dst_extent_;
}

void CowMergeOperation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CowMergeOperation::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.CowMergeOperation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(src_extent_ != nullptr);
      src_extent_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(dst_extent_ != nullptr);
      dst_extent_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&src_offset_) -
        reinterpret_cast<char*>(&type_)) + sizeof(src_offset_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CowMergeOperation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .chromeos_update_engine.CowMergeOperation.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::chromeos_update_engine::CowMergeOperation_Type_IsValid(val))) {
            _internal_set_type(static_cast<::chromeos_update_engine::CowMergeOperation_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .chromeos_update_engine.Extent src_extent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_src_extent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .chromeos_update_engine.Extent dst_extent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_dst_extent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 src_offset = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_src_offset(&has_bits);
          src_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CowMergeOperation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chromeos_update_engine.CowMergeOperation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .chromeos_update_engine.CowMergeOperation.Type type = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional .chromeos_update_engine.Extent src_extent = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::src_extent(this),
        _Internal::src_extent(this).GetCachedSize(), target, stream);
  }

  // optional .chromeos_update_engine.Extent dst_extent = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::dst_extent(this),
        _Internal::dst_extent(this).GetCachedSize(), target, stream);
  }

  // optional uint32 src_offset = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_src_offset(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chromeos_update_engine.CowMergeOperation)
  return target;
}

size_t CowMergeOperation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.CowMergeOperation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .chromeos_update_engine.Extent src_extent = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *src_extent_);
    }

    // optional .chromeos_update_engine.Extent dst_extent = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *dst_extent_);
    }

    // optional .chromeos_update_engine.CowMergeOperation.Type type = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional uint32 src_offset = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_src_offset());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CowMergeOperation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CowMergeOperation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CowMergeOperation::GetClassData() const { return &_class_data_; }

void CowMergeOperation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CowMergeOperation *>(to)->MergeFrom(
      static_cast<const CowMergeOperation &>(from));
}


void CowMergeOperation::MergeFrom(const CowMergeOperation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.CowMergeOperation)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_src_extent()->::chromeos_update_engine::Extent::MergeFrom(from._internal_src_extent());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_dst_extent()->::chromeos_update_engine::Extent::MergeFrom(from._internal_dst_extent());
    }
    if (cached_has_bits & 0x00000004u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      src_offset_ = from.src_offset_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CowMergeOperation::CopyFrom(const CowMergeOperation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.CowMergeOperation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CowMergeOperation::IsInitialized() const {
  return true;
}

void CowMergeOperation::InternalSwap(CowMergeOperation* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CowMergeOperation, src_offset_)
      + sizeof(CowMergeOperation::src_offset_)
      - PROTOBUF_FIELD_OFFSET(CowMergeOperation, src_extent_)>(
          reinterpret_cast<char*>(&src_extent_),
          reinterpret_cast<char*>(&other->src_extent_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CowMergeOperation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_update_5fmetadata_2eproto_getter, &descriptor_table_update_5fmetadata_2eproto_once,
      file_level_metadata_update_5fmetadata_2eproto[5]);
}

// ===================================================================

class PartitionUpdate::_Internal {
 public:
  using HasBits = decltype(std::declval<PartitionUpdate>()._has_bits_);
  static void set_has_partition_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_run_postinstall(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_postinstall_path(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_filesystem_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::chromeos_update_engine::PartitionInfo& old_partition_info(const PartitionUpdate* msg);
  static void set_has_old_partition_info(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::chromeos_update_engine::PartitionInfo& new_partition_info(const PartitionUpdate* msg);
  static void set_has_new_partition_info(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_postinstall_optional(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static const ::chromeos_update_engine::Extent& hash_tree_data_extent(const PartitionUpdate* msg);
  static void set_has_hash_tree_data_extent(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::chromeos_update_engine::Extent& hash_tree_extent(const PartitionUpdate* msg);
  static void set_has_hash_tree_extent(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_hash_tree_algorithm(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_hash_tree_salt(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::chromeos_update_engine::Extent& fec_data_extent(const PartitionUpdate* msg);
  static void set_has_fec_data_extent(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::chromeos_update_engine::Extent& fec_extent(const PartitionUpdate* msg);
  static void set_has_fec_extent(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_fec_roots(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_estimate_cow_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_estimate_op_count_max(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::chromeos_update_engine::PartitionInfo&
PartitionUpdate::_Internal::old_partition_info(const PartitionUpdate* msg) {
  return *msg->old_partition_info_;
}
const ::chromeos_update_engine::PartitionInfo&
PartitionUpdate::_Internal::new_partition_info(const PartitionUpdate* msg) {
  return *msg->new_partition_info_;
}
const ::chromeos_update_engine::Extent&
PartitionUpdate::_Internal::hash_tree_data_extent(const PartitionUpdate* msg) {
  return *msg->hash_tree_data_extent_;
}
const ::chromeos_update_engine::Extent&
PartitionUpdate::_Internal::hash_tree_extent(const PartitionUpdate* msg) {
  return *msg->hash_tree_extent_;
}
const ::chromeos_update_engine::Extent&
PartitionUpdate::_Internal::fec_data_extent(const PartitionUpdate* msg) {
  return *msg->fec_data_extent_;
}
const ::chromeos_update_engine::Extent&
PartitionUpdate::_Internal::fec_extent(const PartitionUpdate* msg) {
  return *msg->fec_extent_;
}
PartitionUpdate::PartitionUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  new_partition_signature_(arena),
  operations_(arena),
  merge_operations_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:chromeos_update_engine.PartitionUpdate)
}
PartitionUpdate::PartitionUpdate(const PartitionUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      new_partition_signature_(from.new_partition_signature_),
      operations_(from.operations_),
      merge_operations_(from.merge_operations_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  partition_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    partition_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_partition_name()) {
    partition_name_.Set(from._internal_partition_name(), 
      GetArenaForAllocation());
  }
  postinstall_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    postinstall_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_postinstall_path()) {
    postinstall_path_.Set(from._internal_postinstall_path(), 
      GetArenaForAllocation());
  }
  filesystem_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    filesystem_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_filesystem_type()) {
    filesystem_type_.Set(from._internal_filesystem_type(), 
      GetArenaForAllocation());
  }
  hash_tree_algorithm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    hash_tree_algorithm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hash_tree_algorithm()) {
    hash_tree_algorithm_.Set(from._internal_hash_tree_algorithm(), 
      GetArenaForAllocation());
  }
  hash_tree_salt_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    hash_tree_salt_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hash_tree_salt()) {
    hash_tree_salt_.Set(from._internal_hash_tree_salt(), 
      GetArenaForAllocation());
  }
  version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_version()) {
    version_.Set(from._internal_version(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_old_partition_info()) {
    old_partition_info_ = new ::chromeos_update_engine::PartitionInfo(*from.old_partition_info_);
  } else {
    old_partition_info_ = nullptr;
  }
  if (from._internal_has_new_partition_info()) {
    new_partition_info_ = new ::chromeos_update_engine::PartitionInfo(*from.new_partition_info_);
  } else {
    new_partition_info_ = nullptr;
  }
  if (from._internal_has_hash_tree_data_extent()) {
    hash_tree_data_extent_ = new ::chromeos_update_engine::Extent(*from.hash_tree_data_extent_);
  } else {
    hash_tree_data_extent_ = nullptr;
  }
  if (from._internal_has_hash_tree_extent()) {
    hash_tree_extent_ = new ::chromeos_update_engine::Extent(*from.hash_tree_extent_);
  } else {
    hash_tree_extent_ = nullptr;
  }
  if (from._internal_has_fec_data_extent()) {
    fec_data_extent_ = new ::chromeos_update_engine::Extent(*from.fec_data_extent_);
  } else {
    fec_data_extent_ = nullptr;
  }
  if (from._internal_has_fec_extent()) {
    fec_extent_ = new ::chromeos_update_engine::Extent(*from.fec_extent_);
  } else {
    fec_extent_ = nullptr;
  }
  ::memcpy(&estimate_cow_size_, &from.estimate_cow_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&fec_roots_) -
    reinterpret_cast<char*>(&estimate_cow_size_)) + sizeof(fec_roots_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.PartitionUpdate)
}

inline void PartitionUpdate::SharedCtor() {
partition_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  partition_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
postinstall_path_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  postinstall_path_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
filesystem_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  filesystem_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
hash_tree_algorithm_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  hash_tree_algorithm_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
hash_tree_salt_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  hash_tree_salt_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&old_partition_info_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&postinstall_optional_) -
    reinterpret_cast<char*>(&old_partition_info_)) + sizeof(postinstall_optional_));
fec_roots_ = 2u;
}

PartitionUpdate::~PartitionUpdate() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.PartitionUpdate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PartitionUpdate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  partition_name_.Destroy();
  postinstall_path_.Destroy();
  filesystem_type_.Destroy();
  hash_tree_algorithm_.Destroy();
  hash_tree_salt_.Destroy();
  version_.Destroy();
  if (this != internal_default_instance()) delete old_partition_info_;
  if (this != internal_default_instance()) delete new_partition_info_;
  if (this != internal_default_instance()) delete hash_tree_data_extent_;
  if (this != internal_default_instance()) delete hash_tree_extent_;
  if (this != internal_default_instance()) delete fec_data_extent_;
  if (this != internal_default_instance()) delete fec_extent_;
}

void PartitionUpdate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PartitionUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.PartitionUpdate)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  new_partition_signature_.Clear();
  operations_.Clear();
  merge_operations_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      partition_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      postinstall_path_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      filesystem_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      hash_tree_algorithm_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      hash_tree_salt_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(old_partition_info_ != nullptr);
      old_partition_info_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(new_partition_info_ != nullptr);
      new_partition_info_->Clear();
    }
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(hash_tree_data_extent_ != nullptr);
      hash_tree_data_extent_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(hash_tree_extent_ != nullptr);
      hash_tree_extent_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(fec_data_extent_ != nullptr);
      fec_data_extent_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(fec_extent_ != nullptr);
      fec_extent_->Clear();
    }
  }
  if (cached_has_bits & 0x0000f000u) {
    ::memset(&estimate_cow_size_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&postinstall_optional_) -
        reinterpret_cast<char*>(&estimate_cow_size_)) + sizeof(postinstall_optional_));
  }
  fec_roots_ = 2u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PartitionUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string partition_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_partition_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "chromeos_update_engine.PartitionUpdate.partition_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool run_postinstall = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_run_postinstall(&has_bits);
          run_postinstall_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string postinstall_path = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_postinstall_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "chromeos_update_engine.PartitionUpdate.postinstall_path");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string filesystem_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_filesystem_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "chromeos_update_engine.PartitionUpdate.filesystem_type");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_new_partition_signature(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_old_partition_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_new_partition_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .chromeos_update_engine.InstallOperation operations = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_operations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool postinstall_optional = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_postinstall_optional(&has_bits);
          postinstall_optional_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_hash_tree_data_extent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .chromeos_update_engine.Extent hash_tree_extent = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_hash_tree_extent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string hash_tree_algorithm = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_hash_tree_algorithm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "chromeos_update_engine.PartitionUpdate.hash_tree_algorithm");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bytes hash_tree_salt = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_hash_tree_salt();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .chromeos_update_engine.Extent fec_data_extent = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_fec_data_extent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .chromeos_update_engine.Extent fec_extent = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_fec_extent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 fec_roots = 16 [default = 2];
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_fec_roots(&has_bits);
          fec_roots_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string version = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "chromeos_update_engine.PartitionUpdate.version");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_merge_operations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<146>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 estimate_cow_size = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_estimate_cow_size(&has_bits);
          estimate_cow_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 estimate_op_count_max = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_estimate_op_count_max(&has_bits);
          estimate_op_count_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PartitionUpdate::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chromeos_update_engine.PartitionUpdate)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string partition_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_partition_name().data(), static_cast<int>(this->_internal_partition_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "chromeos_update_engine.PartitionUpdate.partition_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_partition_name(), target);
  }

  // optional bool run_postinstall = 2;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_run_postinstall(), target);
  }

  // optional string postinstall_path = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_postinstall_path().data(), static_cast<int>(this->_internal_postinstall_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "chromeos_update_engine.PartitionUpdate.postinstall_path");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_postinstall_path(), target);
  }

  // optional string filesystem_type = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_filesystem_type().data(), static_cast<int>(this->_internal_filesystem_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "chromeos_update_engine.PartitionUpdate.filesystem_type");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_filesystem_type(), target);
  }

  // repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_new_partition_signature_size()); i < n; i++) {
    const auto& repfield = this->_internal_new_partition_signature(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::old_partition_info(this),
        _Internal::old_partition_info(this).GetCachedSize(), target, stream);
  }

  // optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::new_partition_info(this),
        _Internal::new_partition_info(this).GetCachedSize(), target, stream);
  }

  // repeated .chromeos_update_engine.InstallOperation operations = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_operations_size()); i < n; i++) {
    const auto& repfield = this->_internal_operations(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool postinstall_optional = 9;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_postinstall_optional(), target);
  }

  // optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::hash_tree_data_extent(this),
        _Internal::hash_tree_data_extent(this).GetCachedSize(), target, stream);
  }

  // optional .chromeos_update_engine.Extent hash_tree_extent = 11;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::hash_tree_extent(this),
        _Internal::hash_tree_extent(this).GetCachedSize(), target, stream);
  }

  // optional string hash_tree_algorithm = 12;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_hash_tree_algorithm().data(), static_cast<int>(this->_internal_hash_tree_algorithm().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "chromeos_update_engine.PartitionUpdate.hash_tree_algorithm");
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_hash_tree_algorithm(), target);
  }

  // optional bytes hash_tree_salt = 13;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        13, this->_internal_hash_tree_salt(), target);
  }

  // optional .chromeos_update_engine.Extent fec_data_extent = 14;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::fec_data_extent(this),
        _Internal::fec_data_extent(this).GetCachedSize(), target, stream);
  }

  // optional .chromeos_update_engine.Extent fec_extent = 15;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::fec_extent(this),
        _Internal::fec_extent(this).GetCachedSize(), target, stream);
  }

  // optional uint32 fec_roots = 16 [default = 2];
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(16, this->_internal_fec_roots(), target);
  }

  // optional string version = 17;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_version().data(), static_cast<int>(this->_internal_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "chromeos_update_engine.PartitionUpdate.version");
    target = stream->WriteStringMaybeAliased(
        17, this->_internal_version(), target);
  }

  // repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_merge_operations_size()); i < n; i++) {
    const auto& repfield = this->_internal_merge_operations(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(18, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint64 estimate_cow_size = 19;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(19, this->_internal_estimate_cow_size(), target);
  }

  // optional uint64 estimate_op_count_max = 20;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(20, this->_internal_estimate_op_count_max(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chromeos_update_engine.PartitionUpdate)
  return target;
}

size_t PartitionUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.PartitionUpdate)
  size_t total_size = 0;

  // required string partition_name = 1;
  if (_internal_has_partition_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_partition_name());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;
  total_size += 1UL * this->_internal_new_partition_signature_size();
  for (const auto& msg : this->new_partition_signature_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .chromeos_update_engine.InstallOperation operations = 8;
  total_size += 1UL * this->_internal_operations_size();
  for (const auto& msg : this->operations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;
  total_size += 2UL * this->_internal_merge_operations_size();
  for (const auto& msg : this->merge_operations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000feu) {
    // optional string postinstall_path = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_postinstall_path());
    }

    // optional string filesystem_type = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_filesystem_type());
    }

    // optional string hash_tree_algorithm = 12;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_hash_tree_algorithm());
    }

    // optional bytes hash_tree_salt = 13;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_hash_tree_salt());
    }

    // optional string version = 17;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_version());
    }

    // optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *old_partition_info_);
    }

    // optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *new_partition_info_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *hash_tree_data_extent_);
    }

    // optional .chromeos_update_engine.Extent hash_tree_extent = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *hash_tree_extent_);
    }

    // optional .chromeos_update_engine.Extent fec_data_extent = 14;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *fec_data_extent_);
    }

    // optional .chromeos_update_engine.Extent fec_extent = 15;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *fec_extent_);
    }

    // optional uint64 estimate_cow_size = 19;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_estimate_cow_size());
    }

    // optional uint64 estimate_op_count_max = 20;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_estimate_op_count_max());
    }

    // optional bool run_postinstall = 2;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 1;
    }

    // optional bool postinstall_optional = 9;
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 + 1;
    }

  }
  // optional uint32 fec_roots = 16 [default = 2];
  if (cached_has_bits & 0x00010000u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_fec_roots());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PartitionUpdate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PartitionUpdate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PartitionUpdate::GetClassData() const { return &_class_data_; }

void PartitionUpdate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PartitionUpdate *>(to)->MergeFrom(
      static_cast<const PartitionUpdate &>(from));
}


void PartitionUpdate::MergeFrom(const PartitionUpdate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.PartitionUpdate)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  new_partition_signature_.MergeFrom(from.new_partition_signature_);
  operations_.MergeFrom(from.operations_);
  merge_operations_.MergeFrom(from.merge_operations_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_partition_name(from._internal_partition_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_postinstall_path(from._internal_postinstall_path());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_filesystem_type(from._internal_filesystem_type());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_hash_tree_algorithm(from._internal_hash_tree_algorithm());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_hash_tree_salt(from._internal_hash_tree_salt());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_version(from._internal_version());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_old_partition_info()->::chromeos_update_engine::PartitionInfo::MergeFrom(from._internal_old_partition_info());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_new_partition_info()->::chromeos_update_engine::PartitionInfo::MergeFrom(from._internal_new_partition_info());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_mutable_hash_tree_data_extent()->::chromeos_update_engine::Extent::MergeFrom(from._internal_hash_tree_data_extent());
    }
    if (cached_has_bits & 0x00000200u) {
      _internal_mutable_hash_tree_extent()->::chromeos_update_engine::Extent::MergeFrom(from._internal_hash_tree_extent());
    }
    if (cached_has_bits & 0x00000400u) {
      _internal_mutable_fec_data_extent()->::chromeos_update_engine::Extent::MergeFrom(from._internal_fec_data_extent());
    }
    if (cached_has_bits & 0x00000800u) {
      _internal_mutable_fec_extent()->::chromeos_update_engine::Extent::MergeFrom(from._internal_fec_extent());
    }
    if (cached_has_bits & 0x00001000u) {
      estimate_cow_size_ = from.estimate_cow_size_;
    }
    if (cached_has_bits & 0x00002000u) {
      estimate_op_count_max_ = from.estimate_op_count_max_;
    }
    if (cached_has_bits & 0x00004000u) {
      run_postinstall_ = from.run_postinstall_;
    }
    if (cached_has_bits & 0x00008000u) {
      postinstall_optional_ = from.postinstall_optional_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00010000u) {
    _internal_set_fec_roots(from._internal_fec_roots());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PartitionUpdate::CopyFrom(const PartitionUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.PartitionUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PartitionUpdate::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(operations_))
    return false;
  return true;
}

void PartitionUpdate::InternalSwap(PartitionUpdate* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  new_partition_signature_.InternalSwap(&other->new_partition_signature_);
  operations_.InternalSwap(&other->operations_);
  merge_operations_.InternalSwap(&other->merge_operations_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &partition_name_, lhs_arena,
      &other->partition_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &postinstall_path_, lhs_arena,
      &other->postinstall_path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &filesystem_type_, lhs_arena,
      &other->filesystem_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &hash_tree_algorithm_, lhs_arena,
      &other->hash_tree_algorithm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &hash_tree_salt_, lhs_arena,
      &other->hash_tree_salt_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &version_, lhs_arena,
      &other->version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PartitionUpdate, postinstall_optional_)
      + sizeof(PartitionUpdate::postinstall_optional_)
      - PROTOBUF_FIELD_OFFSET(PartitionUpdate, old_partition_info_)>(
          reinterpret_cast<char*>(&old_partition_info_),
          reinterpret_cast<char*>(&other->old_partition_info_));
  swap(fec_roots_, other->fec_roots_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PartitionUpdate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_update_5fmetadata_2eproto_getter, &descriptor_table_update_5fmetadata_2eproto_once,
      file_level_metadata_update_5fmetadata_2eproto[6]);
}

// ===================================================================

class DynamicPartitionGroup::_Internal {
 public:
  using HasBits = decltype(std::declval<DynamicPartitionGroup>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

DynamicPartitionGroup::DynamicPartitionGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  partition_names_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:chromeos_update_engine.DynamicPartitionGroup)
}
DynamicPartitionGroup::DynamicPartitionGroup(const DynamicPartitionGroup& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      partition_names_(from.partition_names_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  size_ = from.size_;
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.DynamicPartitionGroup)
}

inline void DynamicPartitionGroup::SharedCtor() {
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
size_ = uint64_t{0u};
}

DynamicPartitionGroup::~DynamicPartitionGroup() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.DynamicPartitionGroup)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DynamicPartitionGroup::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.Destroy();
}

void DynamicPartitionGroup::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DynamicPartitionGroup::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.DynamicPartitionGroup)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  partition_names_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmpty();
  }
  size_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DynamicPartitionGroup::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "chromeos_update_engine.DynamicPartitionGroup.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint64 size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_size(&has_bits);
          size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string partition_names = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_partition_names();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "chromeos_update_engine.DynamicPartitionGroup.partition_names");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DynamicPartitionGroup::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chromeos_update_engine.DynamicPartitionGroup)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "chromeos_update_engine.DynamicPartitionGroup.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional uint64 size = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_size(), target);
  }

  // repeated string partition_names = 3;
  for (int i = 0, n = this->_internal_partition_names_size(); i < n; i++) {
    const auto& s = this->_internal_partition_names(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "chromeos_update_engine.DynamicPartitionGroup.partition_names");
    target = stream->WriteString(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chromeos_update_engine.DynamicPartitionGroup)
  return target;
}

size_t DynamicPartitionGroup::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.DynamicPartitionGroup)
  size_t total_size = 0;

  // required string name = 1;
  if (_internal_has_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string partition_names = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(partition_names_.size());
  for (int i = 0, n = partition_names_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      partition_names_.Get(i));
  }

  // optional uint64 size = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DynamicPartitionGroup::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DynamicPartitionGroup::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DynamicPartitionGroup::GetClassData() const { return &_class_data_; }

void DynamicPartitionGroup::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DynamicPartitionGroup *>(to)->MergeFrom(
      static_cast<const DynamicPartitionGroup &>(from));
}


void DynamicPartitionGroup::MergeFrom(const DynamicPartitionGroup& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.DynamicPartitionGroup)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  partition_names_.MergeFrom(from.partition_names_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      size_ = from.size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DynamicPartitionGroup::CopyFrom(const DynamicPartitionGroup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.DynamicPartitionGroup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DynamicPartitionGroup::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void DynamicPartitionGroup::InternalSwap(DynamicPartitionGroup* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  partition_names_.InternalSwap(&other->partition_names_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  swap(size_, other->size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DynamicPartitionGroup::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_update_5fmetadata_2eproto_getter, &descriptor_table_update_5fmetadata_2eproto_once,
      file_level_metadata_update_5fmetadata_2eproto[7]);
}

// ===================================================================

class VABCFeatureSet::_Internal {
 public:
  using HasBits = decltype(std::declval<VABCFeatureSet>()._has_bits_);
  static void set_has_threaded(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_batch_writes(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

VABCFeatureSet::VABCFeatureSet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:chromeos_update_engine.VABCFeatureSet)
}
VABCFeatureSet::VABCFeatureSet(const VABCFeatureSet& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&threaded_, &from.threaded_,
    static_cast<size_t>(reinterpret_cast<char*>(&batch_writes_) -
    reinterpret_cast<char*>(&threaded_)) + sizeof(batch_writes_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.VABCFeatureSet)
}

inline void VABCFeatureSet::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&threaded_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&batch_writes_) -
    reinterpret_cast<char*>(&threaded_)) + sizeof(batch_writes_));
}

VABCFeatureSet::~VABCFeatureSet() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.VABCFeatureSet)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VABCFeatureSet::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VABCFeatureSet::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VABCFeatureSet::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.VABCFeatureSet)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&threaded_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&batch_writes_) -
      reinterpret_cast<char*>(&threaded_)) + sizeof(batch_writes_));
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VABCFeatureSet::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool threaded = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_threaded(&has_bits);
          threaded_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool batch_writes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_batch_writes(&has_bits);
          batch_writes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VABCFeatureSet::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chromeos_update_engine.VABCFeatureSet)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool threaded = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_threaded(), target);
  }

  // optional bool batch_writes = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_batch_writes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chromeos_update_engine.VABCFeatureSet)
  return target;
}

size_t VABCFeatureSet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.VABCFeatureSet)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool threaded = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool batch_writes = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VABCFeatureSet::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    VABCFeatureSet::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VABCFeatureSet::GetClassData() const { return &_class_data_; }

void VABCFeatureSet::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<VABCFeatureSet *>(to)->MergeFrom(
      static_cast<const VABCFeatureSet &>(from));
}


void VABCFeatureSet::MergeFrom(const VABCFeatureSet& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.VABCFeatureSet)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      threaded_ = from.threaded_;
    }
    if (cached_has_bits & 0x00000002u) {
      batch_writes_ = from.batch_writes_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VABCFeatureSet::CopyFrom(const VABCFeatureSet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.VABCFeatureSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VABCFeatureSet::IsInitialized() const {
  return true;
}

void VABCFeatureSet::InternalSwap(VABCFeatureSet* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VABCFeatureSet, batch_writes_)
      + sizeof(VABCFeatureSet::batch_writes_)
      - PROTOBUF_FIELD_OFFSET(VABCFeatureSet, threaded_)>(
          reinterpret_cast<char*>(&threaded_),
          reinterpret_cast<char*>(&other->threaded_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VABCFeatureSet::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_update_5fmetadata_2eproto_getter, &descriptor_table_update_5fmetadata_2eproto_once,
      file_level_metadata_update_5fmetadata_2eproto[8]);
}

// ===================================================================

class DynamicPartitionMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<DynamicPartitionMetadata>()._has_bits_);
  static void set_has_snapshot_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_vabc_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_vabc_compression_param(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cow_version(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::chromeos_update_engine::VABCFeatureSet& vabc_feature_set(const DynamicPartitionMetadata* msg);
  static void set_has_vabc_feature_set(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_compression_factor(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::chromeos_update_engine::VABCFeatureSet&
DynamicPartitionMetadata::_Internal::vabc_feature_set(const DynamicPartitionMetadata* msg) {
  return *msg->vabc_feature_set_;
}
DynamicPartitionMetadata::DynamicPartitionMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  groups_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:chromeos_update_engine.DynamicPartitionMetadata)
}
DynamicPartitionMetadata::DynamicPartitionMetadata(const DynamicPartitionMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      groups_(from.groups_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  vabc_compression_param_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    vabc_compression_param_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_vabc_compression_param()) {
    vabc_compression_param_.Set(from._internal_vabc_compression_param(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_vabc_feature_set()) {
    vabc_feature_set_ = new ::chromeos_update_engine::VABCFeatureSet(*from.vabc_feature_set_);
  } else {
    vabc_feature_set_ = nullptr;
  }
  ::memcpy(&snapshot_enabled_, &from.snapshot_enabled_,
    static_cast<size_t>(reinterpret_cast<char*>(&compression_factor_) -
    reinterpret_cast<char*>(&snapshot_enabled_)) + sizeof(compression_factor_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.DynamicPartitionMetadata)
}

inline void DynamicPartitionMetadata::SharedCtor() {
vabc_compression_param_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  vabc_compression_param_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&vabc_feature_set_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&compression_factor_) -
    reinterpret_cast<char*>(&vabc_feature_set_)) + sizeof(compression_factor_));
}

DynamicPartitionMetadata::~DynamicPartitionMetadata() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.DynamicPartitionMetadata)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DynamicPartitionMetadata::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  vabc_compression_param_.Destroy();
  if (this != internal_default_instance()) delete vabc_feature_set_;
}

void DynamicPartitionMetadata::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DynamicPartitionMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.DynamicPartitionMetadata)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  groups_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      vabc_compression_param_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(vabc_feature_set_ != nullptr);
      vabc_feature_set_->Clear();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&snapshot_enabled_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&compression_factor_) -
        reinterpret_cast<char*>(&snapshot_enabled_)) + sizeof(compression_factor_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DynamicPartitionMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_groups(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool snapshot_enabled = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_snapshot_enabled(&has_bits);
          snapshot_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool vabc_enabled = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_vabc_enabled(&has_bits);
          vabc_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string vabc_compression_param = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_vabc_compression_param();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "chromeos_update_engine.DynamicPartitionMetadata.vabc_compression_param");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 cow_version = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_cow_version(&has_bits);
          cow_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .chromeos_update_engine.VABCFeatureSet vabc_feature_set = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_vabc_feature_set(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 compression_factor = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_compression_factor(&has_bits);
          compression_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DynamicPartitionMetadata::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chromeos_update_engine.DynamicPartitionMetadata)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_groups_size()); i < n; i++) {
    const auto& repfield = this->_internal_groups(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool snapshot_enabled = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_snapshot_enabled(), target);
  }

  // optional bool vabc_enabled = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_vabc_enabled(), target);
  }

  // optional string vabc_compression_param = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_vabc_compression_param().data(), static_cast<int>(this->_internal_vabc_compression_param().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "chromeos_update_engine.DynamicPartitionMetadata.vabc_compression_param");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_vabc_compression_param(), target);
  }

  // optional uint32 cow_version = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_cow_version(), target);
  }

  // optional .chromeos_update_engine.VABCFeatureSet vabc_feature_set = 6;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::vabc_feature_set(this),
        _Internal::vabc_feature_set(this).GetCachedSize(), target, stream);
  }

  // optional uint64 compression_factor = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_compression_factor(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chromeos_update_engine.DynamicPartitionMetadata)
  return target;
}

size_t DynamicPartitionMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.DynamicPartitionMetadata)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;
  total_size += 1UL * this->_internal_groups_size();
  for (const auto& msg : this->groups_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string vabc_compression_param = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_vabc_compression_param());
    }

    // optional .chromeos_update_engine.VABCFeatureSet vabc_feature_set = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *vabc_feature_set_);
    }

    // optional bool snapshot_enabled = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool vabc_enabled = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional uint32 cow_version = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_cow_version());
    }

    // optional uint64 compression_factor = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_compression_factor());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DynamicPartitionMetadata::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DynamicPartitionMetadata::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DynamicPartitionMetadata::GetClassData() const { return &_class_data_; }

void DynamicPartitionMetadata::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DynamicPartitionMetadata *>(to)->MergeFrom(
      static_cast<const DynamicPartitionMetadata &>(from));
}


void DynamicPartitionMetadata::MergeFrom(const DynamicPartitionMetadata& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.DynamicPartitionMetadata)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  groups_.MergeFrom(from.groups_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_vabc_compression_param(from._internal_vabc_compression_param());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_vabc_feature_set()->::chromeos_update_engine::VABCFeatureSet::MergeFrom(from._internal_vabc_feature_set());
    }
    if (cached_has_bits & 0x00000004u) {
      snapshot_enabled_ = from.snapshot_enabled_;
    }
    if (cached_has_bits & 0x00000008u) {
      vabc_enabled_ = from.vabc_enabled_;
    }
    if (cached_has_bits & 0x00000010u) {
      cow_version_ = from.cow_version_;
    }
    if (cached_has_bits & 0x00000020u) {
      compression_factor_ = from.compression_factor_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DynamicPartitionMetadata::CopyFrom(const DynamicPartitionMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.DynamicPartitionMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DynamicPartitionMetadata::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(groups_))
    return false;
  return true;
}

void DynamicPartitionMetadata::InternalSwap(DynamicPartitionMetadata* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  groups_.InternalSwap(&other->groups_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &vabc_compression_param_, lhs_arena,
      &other->vabc_compression_param_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DynamicPartitionMetadata, compression_factor_)
      + sizeof(DynamicPartitionMetadata::compression_factor_)
      - PROTOBUF_FIELD_OFFSET(DynamicPartitionMetadata, vabc_feature_set_)>(
          reinterpret_cast<char*>(&vabc_feature_set_),
          reinterpret_cast<char*>(&other->vabc_feature_set_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DynamicPartitionMetadata::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_update_5fmetadata_2eproto_getter, &descriptor_table_update_5fmetadata_2eproto_once,
      file_level_metadata_update_5fmetadata_2eproto[9]);
}

// ===================================================================

class ApexInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ApexInfo>()._has_bits_);
  static void set_has_package_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_compressed(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_decompressed_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ApexInfo::ApexInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:chromeos_update_engine.ApexInfo)
}
ApexInfo::ApexInfo(const ApexInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  package_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    package_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_package_name()) {
    package_name_.Set(from._internal_package_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&version_, &from.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_compressed_) -
    reinterpret_cast<char*>(&version_)) + sizeof(is_compressed_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.ApexInfo)
}

inline void ApexInfo::SharedCtor() {
package_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  package_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&version_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_compressed_) -
    reinterpret_cast<char*>(&version_)) + sizeof(is_compressed_));
}

ApexInfo::~ApexInfo() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.ApexInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ApexInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  package_name_.Destroy();
}

void ApexInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ApexInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.ApexInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    package_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_compressed_) -
        reinterpret_cast<char*>(&version_)) + sizeof(is_compressed_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ApexInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string package_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_package_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "chromeos_update_engine.ApexInfo.package_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int64 version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_compressed = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_is_compressed(&has_bits);
          is_compressed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 decompressed_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_decompressed_size(&has_bits);
          decompressed_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ApexInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chromeos_update_engine.ApexInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string package_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_package_name().data(), static_cast<int>(this->_internal_package_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "chromeos_update_engine.ApexInfo.package_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_package_name(), target);
  }

  // optional int64 version = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_version(), target);
  }

  // optional bool is_compressed = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_compressed(), target);
  }

  // optional int64 decompressed_size = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_decompressed_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chromeos_update_engine.ApexInfo)
  return target;
}

size_t ApexInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.ApexInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string package_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_package_name());
    }

    // optional int64 version = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_version());
    }

    // optional int64 decompressed_size = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_decompressed_size());
    }

    // optional bool is_compressed = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ApexInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ApexInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ApexInfo::GetClassData() const { return &_class_data_; }

void ApexInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ApexInfo *>(to)->MergeFrom(
      static_cast<const ApexInfo &>(from));
}


void ApexInfo::MergeFrom(const ApexInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.ApexInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_package_name(from._internal_package_name());
    }
    if (cached_has_bits & 0x00000002u) {
      version_ = from.version_;
    }
    if (cached_has_bits & 0x00000004u) {
      decompressed_size_ = from.decompressed_size_;
    }
    if (cached_has_bits & 0x00000008u) {
      is_compressed_ = from.is_compressed_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ApexInfo::CopyFrom(const ApexInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.ApexInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApexInfo::IsInitialized() const {
  return true;
}

void ApexInfo::InternalSwap(ApexInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &package_name_, lhs_arena,
      &other->package_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ApexInfo, is_compressed_)
      + sizeof(ApexInfo::is_compressed_)
      - PROTOBUF_FIELD_OFFSET(ApexInfo, version_)>(
          reinterpret_cast<char*>(&version_),
          reinterpret_cast<char*>(&other->version_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ApexInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_update_5fmetadata_2eproto_getter, &descriptor_table_update_5fmetadata_2eproto_once,
      file_level_metadata_update_5fmetadata_2eproto[10]);
}

// ===================================================================

class ApexMetadata::_Internal {
 public:
};

ApexMetadata::ApexMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  apex_info_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:chromeos_update_engine.ApexMetadata)
}
ApexMetadata::ApexMetadata(const ApexMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      apex_info_(from.apex_info_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.ApexMetadata)
}

inline void ApexMetadata::SharedCtor() {
}

ApexMetadata::~ApexMetadata() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.ApexMetadata)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ApexMetadata::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ApexMetadata::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ApexMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.ApexMetadata)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  apex_info_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ApexMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .chromeos_update_engine.ApexInfo apex_info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_apex_info(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ApexMetadata::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chromeos_update_engine.ApexMetadata)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.ApexInfo apex_info = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_apex_info_size()); i < n; i++) {
    const auto& repfield = this->_internal_apex_info(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chromeos_update_engine.ApexMetadata)
  return target;
}

size_t ApexMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.ApexMetadata)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.ApexInfo apex_info = 1;
  total_size += 1UL * this->_internal_apex_info_size();
  for (const auto& msg : this->apex_info_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ApexMetadata::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ApexMetadata::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ApexMetadata::GetClassData() const { return &_class_data_; }

void ApexMetadata::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ApexMetadata *>(to)->MergeFrom(
      static_cast<const ApexMetadata &>(from));
}


void ApexMetadata::MergeFrom(const ApexMetadata& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.ApexMetadata)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  apex_info_.MergeFrom(from.apex_info_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ApexMetadata::CopyFrom(const ApexMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.ApexMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApexMetadata::IsInitialized() const {
  return true;
}

void ApexMetadata::InternalSwap(ApexMetadata* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  apex_info_.InternalSwap(&other->apex_info_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ApexMetadata::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_update_5fmetadata_2eproto_getter, &descriptor_table_update_5fmetadata_2eproto_once,
      file_level_metadata_update_5fmetadata_2eproto[11]);
}

// ===================================================================

class DeltaArchiveManifest::_Internal {
 public:
  using HasBits = decltype(std::declval<DeltaArchiveManifest>()._has_bits_);
  static void set_has_block_size(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_signatures_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_signatures_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_minor_version(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_max_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::chromeos_update_engine::DynamicPartitionMetadata& dynamic_partition_metadata(const DeltaArchiveManifest* msg);
  static void set_has_dynamic_partition_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_partial_update(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_security_patch_level(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::chromeos_update_engine::DynamicPartitionMetadata&
DeltaArchiveManifest::_Internal::dynamic_partition_metadata(const DeltaArchiveManifest* msg) {
  return *msg->dynamic_partition_metadata_;
}
DeltaArchiveManifest::DeltaArchiveManifest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  partitions_(arena),
  apex_info_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:chromeos_update_engine.DeltaArchiveManifest)
}
DeltaArchiveManifest::DeltaArchiveManifest(const DeltaArchiveManifest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      partitions_(from.partitions_),
      apex_info_(from.apex_info_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  security_patch_level_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    security_patch_level_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_security_patch_level()) {
    security_patch_level_.Set(from._internal_security_patch_level(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_dynamic_partition_metadata()) {
    dynamic_partition_metadata_ = new ::chromeos_update_engine::DynamicPartitionMetadata(*from.dynamic_partition_metadata_);
  } else {
    dynamic_partition_metadata_ = nullptr;
  }
  ::memcpy(&signatures_offset_, &from.signatures_offset_,
    static_cast<size_t>(reinterpret_cast<char*>(&block_size_) -
    reinterpret_cast<char*>(&signatures_offset_)) + sizeof(block_size_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.DeltaArchiveManifest)
}

inline void DeltaArchiveManifest::SharedCtor() {
security_patch_level_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  security_patch_level_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dynamic_partition_metadata_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&partial_update_) -
    reinterpret_cast<char*>(&dynamic_partition_metadata_)) + sizeof(partial_update_));
block_size_ = 4096u;
}

DeltaArchiveManifest::~DeltaArchiveManifest() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.DeltaArchiveManifest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeltaArchiveManifest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  security_patch_level_.Destroy();
  if (this != internal_default_instance()) delete dynamic_partition_metadata_;
}

void DeltaArchiveManifest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DeltaArchiveManifest::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.DeltaArchiveManifest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  partitions_.Clear();
  apex_info_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      security_patch_level_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(dynamic_partition_metadata_ != nullptr);
      dynamic_partition_metadata_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&signatures_offset_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&partial_update_) -
        reinterpret_cast<char*>(&signatures_offset_)) + sizeof(partial_update_));
    block_size_ = 4096u;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeltaArchiveManifest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 block_size = 3 [default = 4096];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_block_size(&has_bits);
          block_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 signatures_offset = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_signatures_offset(&has_bits);
          signatures_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 signatures_size = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_signatures_size(&has_bits);
          signatures_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 minor_version = 12 [default = 0];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_minor_version(&has_bits);
          minor_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .chromeos_update_engine.PartitionUpdate partitions = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_partitions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int64 max_timestamp = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_max_timestamp(&has_bits);
          max_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_dynamic_partition_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool partial_update = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_partial_update(&has_bits);
          partial_update_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .chromeos_update_engine.ApexInfo apex_info = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_apex_info(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<138>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string security_patch_level = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          auto str = _internal_mutable_security_patch_level();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "chromeos_update_engine.DeltaArchiveManifest.security_patch_level");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeltaArchiveManifest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chromeos_update_engine.DeltaArchiveManifest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 block_size = 3 [default = 4096];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_block_size(), target);
  }

  // optional uint64 signatures_offset = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_signatures_offset(), target);
  }

  // optional uint64 signatures_size = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_signatures_size(), target);
  }

  // optional uint32 minor_version = 12 [default = 0];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_minor_version(), target);
  }

  // repeated .chromeos_update_engine.PartitionUpdate partitions = 13;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_partitions_size()); i < n; i++) {
    const auto& repfield = this->_internal_partitions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional int64 max_timestamp = 14;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(14, this->_internal_max_timestamp(), target);
  }

  // optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::dynamic_partition_metadata(this),
        _Internal::dynamic_partition_metadata(this).GetCachedSize(), target, stream);
  }

  // optional bool partial_update = 16;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_partial_update(), target);
  }

  // repeated .chromeos_update_engine.ApexInfo apex_info = 17;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_apex_info_size()); i < n; i++) {
    const auto& repfield = this->_internal_apex_info(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(17, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string security_patch_level = 18;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_security_patch_level().data(), static_cast<int>(this->_internal_security_patch_level().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "chromeos_update_engine.DeltaArchiveManifest.security_patch_level");
    target = stream->WriteStringMaybeAliased(
        18, this->_internal_security_patch_level(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chromeos_update_engine.DeltaArchiveManifest)
  return target;
}

size_t DeltaArchiveManifest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.DeltaArchiveManifest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.PartitionUpdate partitions = 13;
  total_size += 1UL * this->_internal_partitions_size();
  for (const auto& msg : this->partitions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .chromeos_update_engine.ApexInfo apex_info = 17;
  total_size += 2UL * this->_internal_apex_info_size();
  for (const auto& msg : this->apex_info_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string security_patch_level = 18;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_security_patch_level());
    }

    // optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *dynamic_partition_metadata_);
    }

    // optional uint64 signatures_offset = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_signatures_offset());
    }

    // optional uint64 signatures_size = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_signatures_size());
    }

    // optional int64 max_timestamp = 14;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_max_timestamp());
    }

    // optional uint32 minor_version = 12 [default = 0];
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_minor_version());
    }

    // optional bool partial_update = 16;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 + 1;
    }

    // optional uint32 block_size = 3 [default = 4096];
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_block_size());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeltaArchiveManifest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DeltaArchiveManifest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeltaArchiveManifest::GetClassData() const { return &_class_data_; }

void DeltaArchiveManifest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DeltaArchiveManifest *>(to)->MergeFrom(
      static_cast<const DeltaArchiveManifest &>(from));
}


void DeltaArchiveManifest::MergeFrom(const DeltaArchiveManifest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.DeltaArchiveManifest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  partitions_.MergeFrom(from.partitions_);
  apex_info_.MergeFrom(from.apex_info_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_security_patch_level(from._internal_security_patch_level());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_dynamic_partition_metadata()->::chromeos_update_engine::DynamicPartitionMetadata::MergeFrom(from._internal_dynamic_partition_metadata());
    }
    if (cached_has_bits & 0x00000004u) {
      signatures_offset_ = from.signatures_offset_;
    }
    if (cached_has_bits & 0x00000008u) {
      signatures_size_ = from.signatures_size_;
    }
    if (cached_has_bits & 0x00000010u) {
      max_timestamp_ = from.max_timestamp_;
    }
    if (cached_has_bits & 0x00000020u) {
      minor_version_ = from.minor_version_;
    }
    if (cached_has_bits & 0x00000040u) {
      partial_update_ = from.partial_update_;
    }
    if (cached_has_bits & 0x00000080u) {
      block_size_ = from.block_size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeltaArchiveManifest::CopyFrom(const DeltaArchiveManifest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.DeltaArchiveManifest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeltaArchiveManifest::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(partitions_))
    return false;
  if (_internal_has_dynamic_partition_metadata()) {
    if (!dynamic_partition_metadata_->IsInitialized()) return false;
  }
  return true;
}

void DeltaArchiveManifest::InternalSwap(DeltaArchiveManifest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  partitions_.InternalSwap(&other->partitions_);
  apex_info_.InternalSwap(&other->apex_info_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &security_patch_level_, lhs_arena,
      &other->security_patch_level_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DeltaArchiveManifest, partial_update_)
      + sizeof(DeltaArchiveManifest::partial_update_)
      - PROTOBUF_FIELD_OFFSET(DeltaArchiveManifest, dynamic_partition_metadata_)>(
          reinterpret_cast<char*>(&dynamic_partition_metadata_),
          reinterpret_cast<char*>(&other->dynamic_partition_metadata_));
  swap(block_size_, other->block_size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DeltaArchiveManifest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_update_5fmetadata_2eproto_getter, &descriptor_table_update_5fmetadata_2eproto_once,
      file_level_metadata_update_5fmetadata_2eproto[12]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace chromeos_update_engine
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::Extent*
Arena::CreateMaybeMessage< ::chromeos_update_engine::Extent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chromeos_update_engine::Extent >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::Signatures_Signature*
Arena::CreateMaybeMessage< ::chromeos_update_engine::Signatures_Signature >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chromeos_update_engine::Signatures_Signature >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::Signatures*
Arena::CreateMaybeMessage< ::chromeos_update_engine::Signatures >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chromeos_update_engine::Signatures >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::PartitionInfo*
Arena::CreateMaybeMessage< ::chromeos_update_engine::PartitionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chromeos_update_engine::PartitionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::InstallOperation*
Arena::CreateMaybeMessage< ::chromeos_update_engine::InstallOperation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chromeos_update_engine::InstallOperation >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::CowMergeOperation*
Arena::CreateMaybeMessage< ::chromeos_update_engine::CowMergeOperation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chromeos_update_engine::CowMergeOperation >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::PartitionUpdate*
Arena::CreateMaybeMessage< ::chromeos_update_engine::PartitionUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chromeos_update_engine::PartitionUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::DynamicPartitionGroup*
Arena::CreateMaybeMessage< ::chromeos_update_engine::DynamicPartitionGroup >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chromeos_update_engine::DynamicPartitionGroup >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::VABCFeatureSet*
Arena::CreateMaybeMessage< ::chromeos_update_engine::VABCFeatureSet >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chromeos_update_engine::VABCFeatureSet >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::DynamicPartitionMetadata*
Arena::CreateMaybeMessage< ::chromeos_update_engine::DynamicPartitionMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chromeos_update_engine::DynamicPartitionMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::ApexInfo*
Arena::CreateMaybeMessage< ::chromeos_update_engine::ApexInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chromeos_update_engine::ApexInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::ApexMetadata*
Arena::CreateMaybeMessage< ::chromeos_update_engine::ApexMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chromeos_update_engine::ApexMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::DeltaArchiveManifest*
Arena::CreateMaybeMessage< ::chromeos_update_engine::DeltaArchiveManifest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chromeos_update_engine::DeltaArchiveManifest >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
