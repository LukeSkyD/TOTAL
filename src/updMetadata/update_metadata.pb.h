// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: update_metadata.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_update_5fmetadata_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_update_5fmetadata_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_update_5fmetadata_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_update_5fmetadata_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_update_5fmetadata_2eproto;
namespace chromeos_update_engine {
class ApexInfo;
struct ApexInfoDefaultTypeInternal;
extern ApexInfoDefaultTypeInternal _ApexInfo_default_instance_;
class ApexMetadata;
struct ApexMetadataDefaultTypeInternal;
extern ApexMetadataDefaultTypeInternal _ApexMetadata_default_instance_;
class CowMergeOperation;
struct CowMergeOperationDefaultTypeInternal;
extern CowMergeOperationDefaultTypeInternal _CowMergeOperation_default_instance_;
class DeltaArchiveManifest;
struct DeltaArchiveManifestDefaultTypeInternal;
extern DeltaArchiveManifestDefaultTypeInternal _DeltaArchiveManifest_default_instance_;
class DynamicPartitionGroup;
struct DynamicPartitionGroupDefaultTypeInternal;
extern DynamicPartitionGroupDefaultTypeInternal _DynamicPartitionGroup_default_instance_;
class DynamicPartitionMetadata;
struct DynamicPartitionMetadataDefaultTypeInternal;
extern DynamicPartitionMetadataDefaultTypeInternal _DynamicPartitionMetadata_default_instance_;
class Extent;
struct ExtentDefaultTypeInternal;
extern ExtentDefaultTypeInternal _Extent_default_instance_;
class InstallOperation;
struct InstallOperationDefaultTypeInternal;
extern InstallOperationDefaultTypeInternal _InstallOperation_default_instance_;
class PartitionInfo;
struct PartitionInfoDefaultTypeInternal;
extern PartitionInfoDefaultTypeInternal _PartitionInfo_default_instance_;
class PartitionUpdate;
struct PartitionUpdateDefaultTypeInternal;
extern PartitionUpdateDefaultTypeInternal _PartitionUpdate_default_instance_;
class Signatures;
struct SignaturesDefaultTypeInternal;
extern SignaturesDefaultTypeInternal _Signatures_default_instance_;
class Signatures_Signature;
struct Signatures_SignatureDefaultTypeInternal;
extern Signatures_SignatureDefaultTypeInternal _Signatures_Signature_default_instance_;
class VABCFeatureSet;
struct VABCFeatureSetDefaultTypeInternal;
extern VABCFeatureSetDefaultTypeInternal _VABCFeatureSet_default_instance_;
}  // namespace chromeos_update_engine
PROTOBUF_NAMESPACE_OPEN
template<> ::chromeos_update_engine::ApexInfo* Arena::CreateMaybeMessage<::chromeos_update_engine::ApexInfo>(Arena*);
template<> ::chromeos_update_engine::ApexMetadata* Arena::CreateMaybeMessage<::chromeos_update_engine::ApexMetadata>(Arena*);
template<> ::chromeos_update_engine::CowMergeOperation* Arena::CreateMaybeMessage<::chromeos_update_engine::CowMergeOperation>(Arena*);
template<> ::chromeos_update_engine::DeltaArchiveManifest* Arena::CreateMaybeMessage<::chromeos_update_engine::DeltaArchiveManifest>(Arena*);
template<> ::chromeos_update_engine::DynamicPartitionGroup* Arena::CreateMaybeMessage<::chromeos_update_engine::DynamicPartitionGroup>(Arena*);
template<> ::chromeos_update_engine::DynamicPartitionMetadata* Arena::CreateMaybeMessage<::chromeos_update_engine::DynamicPartitionMetadata>(Arena*);
template<> ::chromeos_update_engine::Extent* Arena::CreateMaybeMessage<::chromeos_update_engine::Extent>(Arena*);
template<> ::chromeos_update_engine::InstallOperation* Arena::CreateMaybeMessage<::chromeos_update_engine::InstallOperation>(Arena*);
template<> ::chromeos_update_engine::PartitionInfo* Arena::CreateMaybeMessage<::chromeos_update_engine::PartitionInfo>(Arena*);
template<> ::chromeos_update_engine::PartitionUpdate* Arena::CreateMaybeMessage<::chromeos_update_engine::PartitionUpdate>(Arena*);
template<> ::chromeos_update_engine::Signatures* Arena::CreateMaybeMessage<::chromeos_update_engine::Signatures>(Arena*);
template<> ::chromeos_update_engine::Signatures_Signature* Arena::CreateMaybeMessage<::chromeos_update_engine::Signatures_Signature>(Arena*);
template<> ::chromeos_update_engine::VABCFeatureSet* Arena::CreateMaybeMessage<::chromeos_update_engine::VABCFeatureSet>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace chromeos_update_engine {

enum InstallOperation_Type : int {
  InstallOperation_Type_REPLACE = 0,
  InstallOperation_Type_REPLACE_BZ = 1,
  InstallOperation_Type_MOVE = 2,
  InstallOperation_Type_BSDIFF = 3,
  InstallOperation_Type_SOURCE_COPY = 4,
  InstallOperation_Type_SOURCE_BSDIFF = 5,
  InstallOperation_Type_REPLACE_XZ = 8,
  InstallOperation_Type_ZERO = 6,
  InstallOperation_Type_DISCARD = 7,
  InstallOperation_Type_BROTLI_BSDIFF = 10,
  InstallOperation_Type_PUFFDIFF = 9,
  InstallOperation_Type_ZUCCHINI = 11,
  InstallOperation_Type_LZ4DIFF_BSDIFF = 12,
  InstallOperation_Type_LZ4DIFF_PUFFDIFF = 13
};
bool InstallOperation_Type_IsValid(int value);
constexpr InstallOperation_Type InstallOperation_Type_Type_MIN = InstallOperation_Type_REPLACE;
constexpr InstallOperation_Type InstallOperation_Type_Type_MAX = InstallOperation_Type_LZ4DIFF_PUFFDIFF;
constexpr int InstallOperation_Type_Type_ARRAYSIZE = InstallOperation_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InstallOperation_Type_descriptor();
template<typename T>
inline const std::string& InstallOperation_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InstallOperation_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InstallOperation_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InstallOperation_Type_descriptor(), enum_t_value);
}
inline bool InstallOperation_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InstallOperation_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InstallOperation_Type>(
    InstallOperation_Type_descriptor(), name, value);
}
enum CowMergeOperation_Type : int {
  CowMergeOperation_Type_COW_COPY = 0,
  CowMergeOperation_Type_COW_XOR = 1,
  CowMergeOperation_Type_COW_REPLACE = 2
};
bool CowMergeOperation_Type_IsValid(int value);
constexpr CowMergeOperation_Type CowMergeOperation_Type_Type_MIN = CowMergeOperation_Type_COW_COPY;
constexpr CowMergeOperation_Type CowMergeOperation_Type_Type_MAX = CowMergeOperation_Type_COW_REPLACE;
constexpr int CowMergeOperation_Type_Type_ARRAYSIZE = CowMergeOperation_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CowMergeOperation_Type_descriptor();
template<typename T>
inline const std::string& CowMergeOperation_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CowMergeOperation_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CowMergeOperation_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CowMergeOperation_Type_descriptor(), enum_t_value);
}
inline bool CowMergeOperation_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CowMergeOperation_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CowMergeOperation_Type>(
    CowMergeOperation_Type_descriptor(), name, value);
}
// ===================================================================

class Extent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chromeos_update_engine.Extent) */ {
 public:
  inline Extent() : Extent(nullptr) {}
  ~Extent() override;
  explicit PROTOBUF_CONSTEXPR Extent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Extent(const Extent& from);
  Extent(Extent&& from) noexcept
    : Extent() {
    *this = ::std::move(from);
  }

  inline Extent& operator=(const Extent& from) {
    CopyFrom(from);
    return *this;
  }
  inline Extent& operator=(Extent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Extent& default_instance() {
    return *internal_default_instance();
  }
  static inline const Extent* internal_default_instance() {
    return reinterpret_cast<const Extent*>(
               &_Extent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Extent& a, Extent& b) {
    a.Swap(&b);
  }
  inline void Swap(Extent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Extent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Extent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Extent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Extent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Extent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Extent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chromeos_update_engine.Extent";
  }
  protected:
  explicit Extent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartBlockFieldNumber = 1,
    kNumBlocksFieldNumber = 2,
  };
  // optional uint64 start_block = 1;
  bool has_start_block() const;
  private:
  bool _internal_has_start_block() const;
  public:
  void clear_start_block();
  uint64_t start_block() const;
  void set_start_block(uint64_t value);
  private:
  uint64_t _internal_start_block() const;
  void _internal_set_start_block(uint64_t value);
  public:

  // optional uint64 num_blocks = 2;
  bool has_num_blocks() const;
  private:
  bool _internal_has_num_blocks() const;
  public:
  void clear_num_blocks();
  uint64_t num_blocks() const;
  void set_num_blocks(uint64_t value);
  private:
  uint64_t _internal_num_blocks() const;
  void _internal_set_num_blocks(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.Extent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t start_block_;
  uint64_t num_blocks_;
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class Signatures_Signature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chromeos_update_engine.Signatures.Signature) */ {
 public:
  inline Signatures_Signature() : Signatures_Signature(nullptr) {}
  ~Signatures_Signature() override;
  explicit PROTOBUF_CONSTEXPR Signatures_Signature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Signatures_Signature(const Signatures_Signature& from);
  Signatures_Signature(Signatures_Signature&& from) noexcept
    : Signatures_Signature() {
    *this = ::std::move(from);
  }

  inline Signatures_Signature& operator=(const Signatures_Signature& from) {
    CopyFrom(from);
    return *this;
  }
  inline Signatures_Signature& operator=(Signatures_Signature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Signatures_Signature& default_instance() {
    return *internal_default_instance();
  }
  static inline const Signatures_Signature* internal_default_instance() {
    return reinterpret_cast<const Signatures_Signature*>(
               &_Signatures_Signature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Signatures_Signature& a, Signatures_Signature& b) {
    a.Swap(&b);
  }
  inline void Swap(Signatures_Signature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Signatures_Signature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Signatures_Signature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Signatures_Signature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Signatures_Signature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Signatures_Signature& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Signatures_Signature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chromeos_update_engine.Signatures.Signature";
  }
  protected:
  explicit Signatures_Signature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kVersionFieldNumber = 1,
    kUnpaddedSignatureSizeFieldNumber = 3,
  };
  // optional bytes data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // optional uint32 version = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  PROTOBUF_DEPRECATED void clear_version();
  PROTOBUF_DEPRECATED uint32_t version() const;
  PROTOBUF_DEPRECATED void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // optional fixed32 unpadded_signature_size = 3;
  bool has_unpadded_signature_size() const;
  private:
  bool _internal_has_unpadded_signature_size() const;
  public:
  void clear_unpadded_signature_size();
  uint32_t unpadded_signature_size() const;
  void set_unpadded_signature_size(uint32_t value);
  private:
  uint32_t _internal_unpadded_signature_size() const;
  void _internal_set_unpadded_signature_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.Signatures.Signature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  uint32_t version_;
  uint32_t unpadded_signature_size_;
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class Signatures final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chromeos_update_engine.Signatures) */ {
 public:
  inline Signatures() : Signatures(nullptr) {}
  ~Signatures() override;
  explicit PROTOBUF_CONSTEXPR Signatures(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Signatures(const Signatures& from);
  Signatures(Signatures&& from) noexcept
    : Signatures() {
    *this = ::std::move(from);
  }

  inline Signatures& operator=(const Signatures& from) {
    CopyFrom(from);
    return *this;
  }
  inline Signatures& operator=(Signatures&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Signatures& default_instance() {
    return *internal_default_instance();
  }
  static inline const Signatures* internal_default_instance() {
    return reinterpret_cast<const Signatures*>(
               &_Signatures_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Signatures& a, Signatures& b) {
    a.Swap(&b);
  }
  inline void Swap(Signatures* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Signatures* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Signatures* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Signatures>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Signatures& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Signatures& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Signatures* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chromeos_update_engine.Signatures";
  }
  protected:
  explicit Signatures(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Signatures_Signature Signature;

  // accessors -------------------------------------------------------

  enum : int {
    kSignaturesFieldNumber = 1,
  };
  // repeated .chromeos_update_engine.Signatures.Signature signatures = 1;
  int signatures_size() const;
  private:
  int _internal_signatures_size() const;
  public:
  void clear_signatures();
  ::chromeos_update_engine::Signatures_Signature* mutable_signatures(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature >*
      mutable_signatures();
  private:
  const ::chromeos_update_engine::Signatures_Signature& _internal_signatures(int index) const;
  ::chromeos_update_engine::Signatures_Signature* _internal_add_signatures();
  public:
  const ::chromeos_update_engine::Signatures_Signature& signatures(int index) const;
  ::chromeos_update_engine::Signatures_Signature* add_signatures();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature >&
      signatures() const;

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.Signatures)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature > signatures_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class PartitionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chromeos_update_engine.PartitionInfo) */ {
 public:
  inline PartitionInfo() : PartitionInfo(nullptr) {}
  ~PartitionInfo() override;
  explicit PROTOBUF_CONSTEXPR PartitionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PartitionInfo(const PartitionInfo& from);
  PartitionInfo(PartitionInfo&& from) noexcept
    : PartitionInfo() {
    *this = ::std::move(from);
  }

  inline PartitionInfo& operator=(const PartitionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartitionInfo& operator=(PartitionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartitionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PartitionInfo* internal_default_instance() {
    return reinterpret_cast<const PartitionInfo*>(
               &_PartitionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PartitionInfo& a, PartitionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PartitionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartitionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PartitionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PartitionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PartitionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PartitionInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartitionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chromeos_update_engine.PartitionInfo";
  }
  protected:
  explicit PartitionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 2,
    kSizeFieldNumber = 1,
  };
  // optional bytes hash = 2;
  bool has_hash() const;
  private:
  bool _internal_has_hash() const;
  public:
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // optional uint64 size = 1;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.PartitionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  uint64_t size_;
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class InstallOperation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chromeos_update_engine.InstallOperation) */ {
 public:
  inline InstallOperation() : InstallOperation(nullptr) {}
  ~InstallOperation() override;
  explicit PROTOBUF_CONSTEXPR InstallOperation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstallOperation(const InstallOperation& from);
  InstallOperation(InstallOperation&& from) noexcept
    : InstallOperation() {
    *this = ::std::move(from);
  }

  inline InstallOperation& operator=(const InstallOperation& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstallOperation& operator=(InstallOperation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstallOperation& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstallOperation* internal_default_instance() {
    return reinterpret_cast<const InstallOperation*>(
               &_InstallOperation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(InstallOperation& a, InstallOperation& b) {
    a.Swap(&b);
  }
  inline void Swap(InstallOperation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstallOperation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstallOperation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InstallOperation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstallOperation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InstallOperation& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstallOperation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chromeos_update_engine.InstallOperation";
  }
  protected:
  explicit InstallOperation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef InstallOperation_Type Type;
  static constexpr Type REPLACE =
    InstallOperation_Type_REPLACE;
  static constexpr Type REPLACE_BZ =
    InstallOperation_Type_REPLACE_BZ;
  PROTOBUF_DEPRECATED_ENUM static constexpr Type MOVE =
    InstallOperation_Type_MOVE;
  PROTOBUF_DEPRECATED_ENUM static constexpr Type BSDIFF =
    InstallOperation_Type_BSDIFF;
  static constexpr Type SOURCE_COPY =
    InstallOperation_Type_SOURCE_COPY;
  static constexpr Type SOURCE_BSDIFF =
    InstallOperation_Type_SOURCE_BSDIFF;
  static constexpr Type REPLACE_XZ =
    InstallOperation_Type_REPLACE_XZ;
  static constexpr Type ZERO =
    InstallOperation_Type_ZERO;
  static constexpr Type DISCARD =
    InstallOperation_Type_DISCARD;
  static constexpr Type BROTLI_BSDIFF =
    InstallOperation_Type_BROTLI_BSDIFF;
  static constexpr Type PUFFDIFF =
    InstallOperation_Type_PUFFDIFF;
  static constexpr Type ZUCCHINI =
    InstallOperation_Type_ZUCCHINI;
  static constexpr Type LZ4DIFF_BSDIFF =
    InstallOperation_Type_LZ4DIFF_BSDIFF;
  static constexpr Type LZ4DIFF_PUFFDIFF =
    InstallOperation_Type_LZ4DIFF_PUFFDIFF;
  static inline bool Type_IsValid(int value) {
    return InstallOperation_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    InstallOperation_Type_Type_MIN;
  static constexpr Type Type_MAX =
    InstallOperation_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    InstallOperation_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return InstallOperation_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return InstallOperation_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return InstallOperation_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSrcExtentsFieldNumber = 4,
    kDstExtentsFieldNumber = 6,
    kDataSha256HashFieldNumber = 8,
    kSrcSha256HashFieldNumber = 9,
    kDataOffsetFieldNumber = 2,
    kDataLengthFieldNumber = 3,
    kSrcLengthFieldNumber = 5,
    kDstLengthFieldNumber = 7,
    kTypeFieldNumber = 1,
  };
  // repeated .chromeos_update_engine.Extent src_extents = 4;
  int src_extents_size() const;
  private:
  int _internal_src_extents_size() const;
  public:
  void clear_src_extents();
  ::chromeos_update_engine::Extent* mutable_src_extents(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Extent >*
      mutable_src_extents();
  private:
  const ::chromeos_update_engine::Extent& _internal_src_extents(int index) const;
  ::chromeos_update_engine::Extent* _internal_add_src_extents();
  public:
  const ::chromeos_update_engine::Extent& src_extents(int index) const;
  ::chromeos_update_engine::Extent* add_src_extents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Extent >&
      src_extents() const;

  // repeated .chromeos_update_engine.Extent dst_extents = 6;
  int dst_extents_size() const;
  private:
  int _internal_dst_extents_size() const;
  public:
  void clear_dst_extents();
  ::chromeos_update_engine::Extent* mutable_dst_extents(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Extent >*
      mutable_dst_extents();
  private:
  const ::chromeos_update_engine::Extent& _internal_dst_extents(int index) const;
  ::chromeos_update_engine::Extent* _internal_add_dst_extents();
  public:
  const ::chromeos_update_engine::Extent& dst_extents(int index) const;
  ::chromeos_update_engine::Extent* add_dst_extents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Extent >&
      dst_extents() const;

  // optional bytes data_sha256_hash = 8;
  bool has_data_sha256_hash() const;
  private:
  bool _internal_has_data_sha256_hash() const;
  public:
  void clear_data_sha256_hash();
  const std::string& data_sha256_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data_sha256_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data_sha256_hash();
  PROTOBUF_NODISCARD std::string* release_data_sha256_hash();
  void set_allocated_data_sha256_hash(std::string* data_sha256_hash);
  private:
  const std::string& _internal_data_sha256_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_sha256_hash(const std::string& value);
  std::string* _internal_mutable_data_sha256_hash();
  public:

  // optional bytes src_sha256_hash = 9;
  bool has_src_sha256_hash() const;
  private:
  bool _internal_has_src_sha256_hash() const;
  public:
  void clear_src_sha256_hash();
  const std::string& src_sha256_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src_sha256_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src_sha256_hash();
  PROTOBUF_NODISCARD std::string* release_src_sha256_hash();
  void set_allocated_src_sha256_hash(std::string* src_sha256_hash);
  private:
  const std::string& _internal_src_sha256_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_sha256_hash(const std::string& value);
  std::string* _internal_mutable_src_sha256_hash();
  public:

  // optional uint64 data_offset = 2;
  bool has_data_offset() const;
  private:
  bool _internal_has_data_offset() const;
  public:
  void clear_data_offset();
  uint64_t data_offset() const;
  void set_data_offset(uint64_t value);
  private:
  uint64_t _internal_data_offset() const;
  void _internal_set_data_offset(uint64_t value);
  public:

  // optional uint64 data_length = 3;
  bool has_data_length() const;
  private:
  bool _internal_has_data_length() const;
  public:
  void clear_data_length();
  uint64_t data_length() const;
  void set_data_length(uint64_t value);
  private:
  uint64_t _internal_data_length() const;
  void _internal_set_data_length(uint64_t value);
  public:

  // optional uint64 src_length = 5;
  bool has_src_length() const;
  private:
  bool _internal_has_src_length() const;
  public:
  void clear_src_length();
  uint64_t src_length() const;
  void set_src_length(uint64_t value);
  private:
  uint64_t _internal_src_length() const;
  void _internal_set_src_length(uint64_t value);
  public:

  // optional uint64 dst_length = 7;
  bool has_dst_length() const;
  private:
  bool _internal_has_dst_length() const;
  public:
  void clear_dst_length();
  uint64_t dst_length() const;
  void set_dst_length(uint64_t value);
  private:
  uint64_t _internal_dst_length() const;
  void _internal_set_dst_length(uint64_t value);
  public:

  // required .chromeos_update_engine.InstallOperation.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::chromeos_update_engine::InstallOperation_Type type() const;
  void set_type(::chromeos_update_engine::InstallOperation_Type value);
  private:
  ::chromeos_update_engine::InstallOperation_Type _internal_type() const;
  void _internal_set_type(::chromeos_update_engine::InstallOperation_Type value);
  public:

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.InstallOperation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Extent > src_extents_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Extent > dst_extents_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_sha256_hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_sha256_hash_;
  uint64_t data_offset_;
  uint64_t data_length_;
  uint64_t src_length_;
  uint64_t dst_length_;
  int type_;
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class CowMergeOperation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chromeos_update_engine.CowMergeOperation) */ {
 public:
  inline CowMergeOperation() : CowMergeOperation(nullptr) {}
  ~CowMergeOperation() override;
  explicit PROTOBUF_CONSTEXPR CowMergeOperation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CowMergeOperation(const CowMergeOperation& from);
  CowMergeOperation(CowMergeOperation&& from) noexcept
    : CowMergeOperation() {
    *this = ::std::move(from);
  }

  inline CowMergeOperation& operator=(const CowMergeOperation& from) {
    CopyFrom(from);
    return *this;
  }
  inline CowMergeOperation& operator=(CowMergeOperation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CowMergeOperation& default_instance() {
    return *internal_default_instance();
  }
  static inline const CowMergeOperation* internal_default_instance() {
    return reinterpret_cast<const CowMergeOperation*>(
               &_CowMergeOperation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CowMergeOperation& a, CowMergeOperation& b) {
    a.Swap(&b);
  }
  inline void Swap(CowMergeOperation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CowMergeOperation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CowMergeOperation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CowMergeOperation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CowMergeOperation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CowMergeOperation& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CowMergeOperation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chromeos_update_engine.CowMergeOperation";
  }
  protected:
  explicit CowMergeOperation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CowMergeOperation_Type Type;
  static constexpr Type COW_COPY =
    CowMergeOperation_Type_COW_COPY;
  static constexpr Type COW_XOR =
    CowMergeOperation_Type_COW_XOR;
  static constexpr Type COW_REPLACE =
    CowMergeOperation_Type_COW_REPLACE;
  static inline bool Type_IsValid(int value) {
    return CowMergeOperation_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    CowMergeOperation_Type_Type_MIN;
  static constexpr Type Type_MAX =
    CowMergeOperation_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    CowMergeOperation_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return CowMergeOperation_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return CowMergeOperation_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return CowMergeOperation_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSrcExtentFieldNumber = 2,
    kDstExtentFieldNumber = 3,
    kTypeFieldNumber = 1,
    kSrcOffsetFieldNumber = 4,
  };
  // optional .chromeos_update_engine.Extent src_extent = 2;
  bool has_src_extent() const;
  private:
  bool _internal_has_src_extent() const;
  public:
  void clear_src_extent();
  const ::chromeos_update_engine::Extent& src_extent() const;
  PROTOBUF_NODISCARD ::chromeos_update_engine::Extent* release_src_extent();
  ::chromeos_update_engine::Extent* mutable_src_extent();
  void set_allocated_src_extent(::chromeos_update_engine::Extent* src_extent);
  private:
  const ::chromeos_update_engine::Extent& _internal_src_extent() const;
  ::chromeos_update_engine::Extent* _internal_mutable_src_extent();
  public:
  void unsafe_arena_set_allocated_src_extent(
      ::chromeos_update_engine::Extent* src_extent);
  ::chromeos_update_engine::Extent* unsafe_arena_release_src_extent();

  // optional .chromeos_update_engine.Extent dst_extent = 3;
  bool has_dst_extent() const;
  private:
  bool _internal_has_dst_extent() const;
  public:
  void clear_dst_extent();
  const ::chromeos_update_engine::Extent& dst_extent() const;
  PROTOBUF_NODISCARD ::chromeos_update_engine::Extent* release_dst_extent();
  ::chromeos_update_engine::Extent* mutable_dst_extent();
  void set_allocated_dst_extent(::chromeos_update_engine::Extent* dst_extent);
  private:
  const ::chromeos_update_engine::Extent& _internal_dst_extent() const;
  ::chromeos_update_engine::Extent* _internal_mutable_dst_extent();
  public:
  void unsafe_arena_set_allocated_dst_extent(
      ::chromeos_update_engine::Extent* dst_extent);
  ::chromeos_update_engine::Extent* unsafe_arena_release_dst_extent();

  // optional .chromeos_update_engine.CowMergeOperation.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::chromeos_update_engine::CowMergeOperation_Type type() const;
  void set_type(::chromeos_update_engine::CowMergeOperation_Type value);
  private:
  ::chromeos_update_engine::CowMergeOperation_Type _internal_type() const;
  void _internal_set_type(::chromeos_update_engine::CowMergeOperation_Type value);
  public:

  // optional uint32 src_offset = 4;
  bool has_src_offset() const;
  private:
  bool _internal_has_src_offset() const;
  public:
  void clear_src_offset();
  uint32_t src_offset() const;
  void set_src_offset(uint32_t value);
  private:
  uint32_t _internal_src_offset() const;
  void _internal_set_src_offset(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.CowMergeOperation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::chromeos_update_engine::Extent* src_extent_;
  ::chromeos_update_engine::Extent* dst_extent_;
  int type_;
  uint32_t src_offset_;
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class PartitionUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chromeos_update_engine.PartitionUpdate) */ {
 public:
  inline PartitionUpdate() : PartitionUpdate(nullptr) {}
  ~PartitionUpdate() override;
  explicit PROTOBUF_CONSTEXPR PartitionUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PartitionUpdate(const PartitionUpdate& from);
  PartitionUpdate(PartitionUpdate&& from) noexcept
    : PartitionUpdate() {
    *this = ::std::move(from);
  }

  inline PartitionUpdate& operator=(const PartitionUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartitionUpdate& operator=(PartitionUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartitionUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const PartitionUpdate* internal_default_instance() {
    return reinterpret_cast<const PartitionUpdate*>(
               &_PartitionUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PartitionUpdate& a, PartitionUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(PartitionUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartitionUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PartitionUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PartitionUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PartitionUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PartitionUpdate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartitionUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chromeos_update_engine.PartitionUpdate";
  }
  protected:
  explicit PartitionUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewPartitionSignatureFieldNumber = 5,
    kOperationsFieldNumber = 8,
    kMergeOperationsFieldNumber = 18,
    kPartitionNameFieldNumber = 1,
    kPostinstallPathFieldNumber = 3,
    kFilesystemTypeFieldNumber = 4,
    kHashTreeAlgorithmFieldNumber = 12,
    kHashTreeSaltFieldNumber = 13,
    kVersionFieldNumber = 17,
    kOldPartitionInfoFieldNumber = 6,
    kNewPartitionInfoFieldNumber = 7,
    kHashTreeDataExtentFieldNumber = 10,
    kHashTreeExtentFieldNumber = 11,
    kFecDataExtentFieldNumber = 14,
    kFecExtentFieldNumber = 15,
    kEstimateCowSizeFieldNumber = 19,
    kEstimateOpCountMaxFieldNumber = 20,
    kRunPostinstallFieldNumber = 2,
    kPostinstallOptionalFieldNumber = 9,
    kFecRootsFieldNumber = 16,
  };
  // repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;
  int new_partition_signature_size() const;
  private:
  int _internal_new_partition_signature_size() const;
  public:
  void clear_new_partition_signature();
  ::chromeos_update_engine::Signatures_Signature* mutable_new_partition_signature(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature >*
      mutable_new_partition_signature();
  private:
  const ::chromeos_update_engine::Signatures_Signature& _internal_new_partition_signature(int index) const;
  ::chromeos_update_engine::Signatures_Signature* _internal_add_new_partition_signature();
  public:
  const ::chromeos_update_engine::Signatures_Signature& new_partition_signature(int index) const;
  ::chromeos_update_engine::Signatures_Signature* add_new_partition_signature();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature >&
      new_partition_signature() const;

  // repeated .chromeos_update_engine.InstallOperation operations = 8;
  int operations_size() const;
  private:
  int _internal_operations_size() const;
  public:
  void clear_operations();
  ::chromeos_update_engine::InstallOperation* mutable_operations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::InstallOperation >*
      mutable_operations();
  private:
  const ::chromeos_update_engine::InstallOperation& _internal_operations(int index) const;
  ::chromeos_update_engine::InstallOperation* _internal_add_operations();
  public:
  const ::chromeos_update_engine::InstallOperation& operations(int index) const;
  ::chromeos_update_engine::InstallOperation* add_operations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::InstallOperation >&
      operations() const;

  // repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;
  int merge_operations_size() const;
  private:
  int _internal_merge_operations_size() const;
  public:
  void clear_merge_operations();
  ::chromeos_update_engine::CowMergeOperation* mutable_merge_operations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::CowMergeOperation >*
      mutable_merge_operations();
  private:
  const ::chromeos_update_engine::CowMergeOperation& _internal_merge_operations(int index) const;
  ::chromeos_update_engine::CowMergeOperation* _internal_add_merge_operations();
  public:
  const ::chromeos_update_engine::CowMergeOperation& merge_operations(int index) const;
  ::chromeos_update_engine::CowMergeOperation* add_merge_operations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::CowMergeOperation >&
      merge_operations() const;

  // required string partition_name = 1;
  bool has_partition_name() const;
  private:
  bool _internal_has_partition_name() const;
  public:
  void clear_partition_name();
  const std::string& partition_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_partition_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_partition_name();
  PROTOBUF_NODISCARD std::string* release_partition_name();
  void set_allocated_partition_name(std::string* partition_name);
  private:
  const std::string& _internal_partition_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_partition_name(const std::string& value);
  std::string* _internal_mutable_partition_name();
  public:

  // optional string postinstall_path = 3;
  bool has_postinstall_path() const;
  private:
  bool _internal_has_postinstall_path() const;
  public:
  void clear_postinstall_path();
  const std::string& postinstall_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_postinstall_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_postinstall_path();
  PROTOBUF_NODISCARD std::string* release_postinstall_path();
  void set_allocated_postinstall_path(std::string* postinstall_path);
  private:
  const std::string& _internal_postinstall_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_postinstall_path(const std::string& value);
  std::string* _internal_mutable_postinstall_path();
  public:

  // optional string filesystem_type = 4;
  bool has_filesystem_type() const;
  private:
  bool _internal_has_filesystem_type() const;
  public:
  void clear_filesystem_type();
  const std::string& filesystem_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filesystem_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filesystem_type();
  PROTOBUF_NODISCARD std::string* release_filesystem_type();
  void set_allocated_filesystem_type(std::string* filesystem_type);
  private:
  const std::string& _internal_filesystem_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filesystem_type(const std::string& value);
  std::string* _internal_mutable_filesystem_type();
  public:

  // optional string hash_tree_algorithm = 12;
  bool has_hash_tree_algorithm() const;
  private:
  bool _internal_has_hash_tree_algorithm() const;
  public:
  void clear_hash_tree_algorithm();
  const std::string& hash_tree_algorithm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash_tree_algorithm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash_tree_algorithm();
  PROTOBUF_NODISCARD std::string* release_hash_tree_algorithm();
  void set_allocated_hash_tree_algorithm(std::string* hash_tree_algorithm);
  private:
  const std::string& _internal_hash_tree_algorithm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash_tree_algorithm(const std::string& value);
  std::string* _internal_mutable_hash_tree_algorithm();
  public:

  // optional bytes hash_tree_salt = 13;
  bool has_hash_tree_salt() const;
  private:
  bool _internal_has_hash_tree_salt() const;
  public:
  void clear_hash_tree_salt();
  const std::string& hash_tree_salt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash_tree_salt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash_tree_salt();
  PROTOBUF_NODISCARD std::string* release_hash_tree_salt();
  void set_allocated_hash_tree_salt(std::string* hash_tree_salt);
  private:
  const std::string& _internal_hash_tree_salt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash_tree_salt(const std::string& value);
  std::string* _internal_mutable_hash_tree_salt();
  public:

  // optional string version = 17;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;
  bool has_old_partition_info() const;
  private:
  bool _internal_has_old_partition_info() const;
  public:
  void clear_old_partition_info();
  const ::chromeos_update_engine::PartitionInfo& old_partition_info() const;
  PROTOBUF_NODISCARD ::chromeos_update_engine::PartitionInfo* release_old_partition_info();
  ::chromeos_update_engine::PartitionInfo* mutable_old_partition_info();
  void set_allocated_old_partition_info(::chromeos_update_engine::PartitionInfo* old_partition_info);
  private:
  const ::chromeos_update_engine::PartitionInfo& _internal_old_partition_info() const;
  ::chromeos_update_engine::PartitionInfo* _internal_mutable_old_partition_info();
  public:
  void unsafe_arena_set_allocated_old_partition_info(
      ::chromeos_update_engine::PartitionInfo* old_partition_info);
  ::chromeos_update_engine::PartitionInfo* unsafe_arena_release_old_partition_info();

  // optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;
  bool has_new_partition_info() const;
  private:
  bool _internal_has_new_partition_info() const;
  public:
  void clear_new_partition_info();
  const ::chromeos_update_engine::PartitionInfo& new_partition_info() const;
  PROTOBUF_NODISCARD ::chromeos_update_engine::PartitionInfo* release_new_partition_info();
  ::chromeos_update_engine::PartitionInfo* mutable_new_partition_info();
  void set_allocated_new_partition_info(::chromeos_update_engine::PartitionInfo* new_partition_info);
  private:
  const ::chromeos_update_engine::PartitionInfo& _internal_new_partition_info() const;
  ::chromeos_update_engine::PartitionInfo* _internal_mutable_new_partition_info();
  public:
  void unsafe_arena_set_allocated_new_partition_info(
      ::chromeos_update_engine::PartitionInfo* new_partition_info);
  ::chromeos_update_engine::PartitionInfo* unsafe_arena_release_new_partition_info();

  // optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;
  bool has_hash_tree_data_extent() const;
  private:
  bool _internal_has_hash_tree_data_extent() const;
  public:
  void clear_hash_tree_data_extent();
  const ::chromeos_update_engine::Extent& hash_tree_data_extent() const;
  PROTOBUF_NODISCARD ::chromeos_update_engine::Extent* release_hash_tree_data_extent();
  ::chromeos_update_engine::Extent* mutable_hash_tree_data_extent();
  void set_allocated_hash_tree_data_extent(::chromeos_update_engine::Extent* hash_tree_data_extent);
  private:
  const ::chromeos_update_engine::Extent& _internal_hash_tree_data_extent() const;
  ::chromeos_update_engine::Extent* _internal_mutable_hash_tree_data_extent();
  public:
  void unsafe_arena_set_allocated_hash_tree_data_extent(
      ::chromeos_update_engine::Extent* hash_tree_data_extent);
  ::chromeos_update_engine::Extent* unsafe_arena_release_hash_tree_data_extent();

  // optional .chromeos_update_engine.Extent hash_tree_extent = 11;
  bool has_hash_tree_extent() const;
  private:
  bool _internal_has_hash_tree_extent() const;
  public:
  void clear_hash_tree_extent();
  const ::chromeos_update_engine::Extent& hash_tree_extent() const;
  PROTOBUF_NODISCARD ::chromeos_update_engine::Extent* release_hash_tree_extent();
  ::chromeos_update_engine::Extent* mutable_hash_tree_extent();
  void set_allocated_hash_tree_extent(::chromeos_update_engine::Extent* hash_tree_extent);
  private:
  const ::chromeos_update_engine::Extent& _internal_hash_tree_extent() const;
  ::chromeos_update_engine::Extent* _internal_mutable_hash_tree_extent();
  public:
  void unsafe_arena_set_allocated_hash_tree_extent(
      ::chromeos_update_engine::Extent* hash_tree_extent);
  ::chromeos_update_engine::Extent* unsafe_arena_release_hash_tree_extent();

  // optional .chromeos_update_engine.Extent fec_data_extent = 14;
  bool has_fec_data_extent() const;
  private:
  bool _internal_has_fec_data_extent() const;
  public:
  void clear_fec_data_extent();
  const ::chromeos_update_engine::Extent& fec_data_extent() const;
  PROTOBUF_NODISCARD ::chromeos_update_engine::Extent* release_fec_data_extent();
  ::chromeos_update_engine::Extent* mutable_fec_data_extent();
  void set_allocated_fec_data_extent(::chromeos_update_engine::Extent* fec_data_extent);
  private:
  const ::chromeos_update_engine::Extent& _internal_fec_data_extent() const;
  ::chromeos_update_engine::Extent* _internal_mutable_fec_data_extent();
  public:
  void unsafe_arena_set_allocated_fec_data_extent(
      ::chromeos_update_engine::Extent* fec_data_extent);
  ::chromeos_update_engine::Extent* unsafe_arena_release_fec_data_extent();

  // optional .chromeos_update_engine.Extent fec_extent = 15;
  bool has_fec_extent() const;
  private:
  bool _internal_has_fec_extent() const;
  public:
  void clear_fec_extent();
  const ::chromeos_update_engine::Extent& fec_extent() const;
  PROTOBUF_NODISCARD ::chromeos_update_engine::Extent* release_fec_extent();
  ::chromeos_update_engine::Extent* mutable_fec_extent();
  void set_allocated_fec_extent(::chromeos_update_engine::Extent* fec_extent);
  private:
  const ::chromeos_update_engine::Extent& _internal_fec_extent() const;
  ::chromeos_update_engine::Extent* _internal_mutable_fec_extent();
  public:
  void unsafe_arena_set_allocated_fec_extent(
      ::chromeos_update_engine::Extent* fec_extent);
  ::chromeos_update_engine::Extent* unsafe_arena_release_fec_extent();

  // optional uint64 estimate_cow_size = 19;
  bool has_estimate_cow_size() const;
  private:
  bool _internal_has_estimate_cow_size() const;
  public:
  void clear_estimate_cow_size();
  uint64_t estimate_cow_size() const;
  void set_estimate_cow_size(uint64_t value);
  private:
  uint64_t _internal_estimate_cow_size() const;
  void _internal_set_estimate_cow_size(uint64_t value);
  public:

  // optional uint64 estimate_op_count_max = 20;
  bool has_estimate_op_count_max() const;
  private:
  bool _internal_has_estimate_op_count_max() const;
  public:
  void clear_estimate_op_count_max();
  uint64_t estimate_op_count_max() const;
  void set_estimate_op_count_max(uint64_t value);
  private:
  uint64_t _internal_estimate_op_count_max() const;
  void _internal_set_estimate_op_count_max(uint64_t value);
  public:

  // optional bool run_postinstall = 2;
  bool has_run_postinstall() const;
  private:
  bool _internal_has_run_postinstall() const;
  public:
  void clear_run_postinstall();
  bool run_postinstall() const;
  void set_run_postinstall(bool value);
  private:
  bool _internal_run_postinstall() const;
  void _internal_set_run_postinstall(bool value);
  public:

  // optional bool postinstall_optional = 9;
  bool has_postinstall_optional() const;
  private:
  bool _internal_has_postinstall_optional() const;
  public:
  void clear_postinstall_optional();
  bool postinstall_optional() const;
  void set_postinstall_optional(bool value);
  private:
  bool _internal_postinstall_optional() const;
  void _internal_set_postinstall_optional(bool value);
  public:

  // optional uint32 fec_roots = 16 [default = 2];
  bool has_fec_roots() const;
  private:
  bool _internal_has_fec_roots() const;
  public:
  void clear_fec_roots();
  uint32_t fec_roots() const;
  void set_fec_roots(uint32_t value);
  private:
  uint32_t _internal_fec_roots() const;
  void _internal_set_fec_roots(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.PartitionUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature > new_partition_signature_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::InstallOperation > operations_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::CowMergeOperation > merge_operations_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partition_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr postinstall_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filesystem_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_tree_algorithm_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_tree_salt_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::chromeos_update_engine::PartitionInfo* old_partition_info_;
  ::chromeos_update_engine::PartitionInfo* new_partition_info_;
  ::chromeos_update_engine::Extent* hash_tree_data_extent_;
  ::chromeos_update_engine::Extent* hash_tree_extent_;
  ::chromeos_update_engine::Extent* fec_data_extent_;
  ::chromeos_update_engine::Extent* fec_extent_;
  uint64_t estimate_cow_size_;
  uint64_t estimate_op_count_max_;
  bool run_postinstall_;
  bool postinstall_optional_;
  uint32_t fec_roots_;
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class DynamicPartitionGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chromeos_update_engine.DynamicPartitionGroup) */ {
 public:
  inline DynamicPartitionGroup() : DynamicPartitionGroup(nullptr) {}
  ~DynamicPartitionGroup() override;
  explicit PROTOBUF_CONSTEXPR DynamicPartitionGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DynamicPartitionGroup(const DynamicPartitionGroup& from);
  DynamicPartitionGroup(DynamicPartitionGroup&& from) noexcept
    : DynamicPartitionGroup() {
    *this = ::std::move(from);
  }

  inline DynamicPartitionGroup& operator=(const DynamicPartitionGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline DynamicPartitionGroup& operator=(DynamicPartitionGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DynamicPartitionGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const DynamicPartitionGroup* internal_default_instance() {
    return reinterpret_cast<const DynamicPartitionGroup*>(
               &_DynamicPartitionGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DynamicPartitionGroup& a, DynamicPartitionGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(DynamicPartitionGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DynamicPartitionGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DynamicPartitionGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DynamicPartitionGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DynamicPartitionGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DynamicPartitionGroup& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DynamicPartitionGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chromeos_update_engine.DynamicPartitionGroup";
  }
  protected:
  explicit DynamicPartitionGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartitionNamesFieldNumber = 3,
    kNameFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // repeated string partition_names = 3;
  int partition_names_size() const;
  private:
  int _internal_partition_names_size() const;
  public:
  void clear_partition_names();
  const std::string& partition_names(int index) const;
  std::string* mutable_partition_names(int index);
  void set_partition_names(int index, const std::string& value);
  void set_partition_names(int index, std::string&& value);
  void set_partition_names(int index, const char* value);
  void set_partition_names(int index, const char* value, size_t size);
  std::string* add_partition_names();
  void add_partition_names(const std::string& value);
  void add_partition_names(std::string&& value);
  void add_partition_names(const char* value);
  void add_partition_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& partition_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_partition_names();
  private:
  const std::string& _internal_partition_names(int index) const;
  std::string* _internal_add_partition_names();
  public:

  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional uint64 size = 2;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.DynamicPartitionGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> partition_names_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  uint64_t size_;
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class VABCFeatureSet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chromeos_update_engine.VABCFeatureSet) */ {
 public:
  inline VABCFeatureSet() : VABCFeatureSet(nullptr) {}
  ~VABCFeatureSet() override;
  explicit PROTOBUF_CONSTEXPR VABCFeatureSet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VABCFeatureSet(const VABCFeatureSet& from);
  VABCFeatureSet(VABCFeatureSet&& from) noexcept
    : VABCFeatureSet() {
    *this = ::std::move(from);
  }

  inline VABCFeatureSet& operator=(const VABCFeatureSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline VABCFeatureSet& operator=(VABCFeatureSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VABCFeatureSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const VABCFeatureSet* internal_default_instance() {
    return reinterpret_cast<const VABCFeatureSet*>(
               &_VABCFeatureSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(VABCFeatureSet& a, VABCFeatureSet& b) {
    a.Swap(&b);
  }
  inline void Swap(VABCFeatureSet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VABCFeatureSet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VABCFeatureSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VABCFeatureSet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VABCFeatureSet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VABCFeatureSet& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VABCFeatureSet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chromeos_update_engine.VABCFeatureSet";
  }
  protected:
  explicit VABCFeatureSet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThreadedFieldNumber = 1,
    kBatchWritesFieldNumber = 2,
  };
  // optional bool threaded = 1;
  bool has_threaded() const;
  private:
  bool _internal_has_threaded() const;
  public:
  void clear_threaded();
  bool threaded() const;
  void set_threaded(bool value);
  private:
  bool _internal_threaded() const;
  void _internal_set_threaded(bool value);
  public:

  // optional bool batch_writes = 2;
  bool has_batch_writes() const;
  private:
  bool _internal_has_batch_writes() const;
  public:
  void clear_batch_writes();
  bool batch_writes() const;
  void set_batch_writes(bool value);
  private:
  bool _internal_batch_writes() const;
  void _internal_set_batch_writes(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.VABCFeatureSet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool threaded_;
  bool batch_writes_;
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class DynamicPartitionMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chromeos_update_engine.DynamicPartitionMetadata) */ {
 public:
  inline DynamicPartitionMetadata() : DynamicPartitionMetadata(nullptr) {}
  ~DynamicPartitionMetadata() override;
  explicit PROTOBUF_CONSTEXPR DynamicPartitionMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DynamicPartitionMetadata(const DynamicPartitionMetadata& from);
  DynamicPartitionMetadata(DynamicPartitionMetadata&& from) noexcept
    : DynamicPartitionMetadata() {
    *this = ::std::move(from);
  }

  inline DynamicPartitionMetadata& operator=(const DynamicPartitionMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline DynamicPartitionMetadata& operator=(DynamicPartitionMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DynamicPartitionMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const DynamicPartitionMetadata* internal_default_instance() {
    return reinterpret_cast<const DynamicPartitionMetadata*>(
               &_DynamicPartitionMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DynamicPartitionMetadata& a, DynamicPartitionMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(DynamicPartitionMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DynamicPartitionMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DynamicPartitionMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DynamicPartitionMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DynamicPartitionMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DynamicPartitionMetadata& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DynamicPartitionMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chromeos_update_engine.DynamicPartitionMetadata";
  }
  protected:
  explicit DynamicPartitionMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupsFieldNumber = 1,
    kVabcCompressionParamFieldNumber = 4,
    kVabcFeatureSetFieldNumber = 6,
    kSnapshotEnabledFieldNumber = 2,
    kVabcEnabledFieldNumber = 3,
    kCowVersionFieldNumber = 5,
    kCompressionFactorFieldNumber = 7,
  };
  // repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;
  int groups_size() const;
  private:
  int _internal_groups_size() const;
  public:
  void clear_groups();
  ::chromeos_update_engine::DynamicPartitionGroup* mutable_groups(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::DynamicPartitionGroup >*
      mutable_groups();
  private:
  const ::chromeos_update_engine::DynamicPartitionGroup& _internal_groups(int index) const;
  ::chromeos_update_engine::DynamicPartitionGroup* _internal_add_groups();
  public:
  const ::chromeos_update_engine::DynamicPartitionGroup& groups(int index) const;
  ::chromeos_update_engine::DynamicPartitionGroup* add_groups();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::DynamicPartitionGroup >&
      groups() const;

  // optional string vabc_compression_param = 4;
  bool has_vabc_compression_param() const;
  private:
  bool _internal_has_vabc_compression_param() const;
  public:
  void clear_vabc_compression_param();
  const std::string& vabc_compression_param() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vabc_compression_param(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vabc_compression_param();
  PROTOBUF_NODISCARD std::string* release_vabc_compression_param();
  void set_allocated_vabc_compression_param(std::string* vabc_compression_param);
  private:
  const std::string& _internal_vabc_compression_param() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vabc_compression_param(const std::string& value);
  std::string* _internal_mutable_vabc_compression_param();
  public:

  // optional .chromeos_update_engine.VABCFeatureSet vabc_feature_set = 6;
  bool has_vabc_feature_set() const;
  private:
  bool _internal_has_vabc_feature_set() const;
  public:
  void clear_vabc_feature_set();
  const ::chromeos_update_engine::VABCFeatureSet& vabc_feature_set() const;
  PROTOBUF_NODISCARD ::chromeos_update_engine::VABCFeatureSet* release_vabc_feature_set();
  ::chromeos_update_engine::VABCFeatureSet* mutable_vabc_feature_set();
  void set_allocated_vabc_feature_set(::chromeos_update_engine::VABCFeatureSet* vabc_feature_set);
  private:
  const ::chromeos_update_engine::VABCFeatureSet& _internal_vabc_feature_set() const;
  ::chromeos_update_engine::VABCFeatureSet* _internal_mutable_vabc_feature_set();
  public:
  void unsafe_arena_set_allocated_vabc_feature_set(
      ::chromeos_update_engine::VABCFeatureSet* vabc_feature_set);
  ::chromeos_update_engine::VABCFeatureSet* unsafe_arena_release_vabc_feature_set();

  // optional bool snapshot_enabled = 2;
  bool has_snapshot_enabled() const;
  private:
  bool _internal_has_snapshot_enabled() const;
  public:
  void clear_snapshot_enabled();
  bool snapshot_enabled() const;
  void set_snapshot_enabled(bool value);
  private:
  bool _internal_snapshot_enabled() const;
  void _internal_set_snapshot_enabled(bool value);
  public:

  // optional bool vabc_enabled = 3;
  bool has_vabc_enabled() const;
  private:
  bool _internal_has_vabc_enabled() const;
  public:
  void clear_vabc_enabled();
  bool vabc_enabled() const;
  void set_vabc_enabled(bool value);
  private:
  bool _internal_vabc_enabled() const;
  void _internal_set_vabc_enabled(bool value);
  public:

  // optional uint32 cow_version = 5;
  bool has_cow_version() const;
  private:
  bool _internal_has_cow_version() const;
  public:
  void clear_cow_version();
  uint32_t cow_version() const;
  void set_cow_version(uint32_t value);
  private:
  uint32_t _internal_cow_version() const;
  void _internal_set_cow_version(uint32_t value);
  public:

  // optional uint64 compression_factor = 7;
  bool has_compression_factor() const;
  private:
  bool _internal_has_compression_factor() const;
  public:
  void clear_compression_factor();
  uint64_t compression_factor() const;
  void set_compression_factor(uint64_t value);
  private:
  uint64_t _internal_compression_factor() const;
  void _internal_set_compression_factor(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.DynamicPartitionMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::DynamicPartitionGroup > groups_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vabc_compression_param_;
  ::chromeos_update_engine::VABCFeatureSet* vabc_feature_set_;
  bool snapshot_enabled_;
  bool vabc_enabled_;
  uint32_t cow_version_;
  uint64_t compression_factor_;
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class ApexInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chromeos_update_engine.ApexInfo) */ {
 public:
  inline ApexInfo() : ApexInfo(nullptr) {}
  ~ApexInfo() override;
  explicit PROTOBUF_CONSTEXPR ApexInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApexInfo(const ApexInfo& from);
  ApexInfo(ApexInfo&& from) noexcept
    : ApexInfo() {
    *this = ::std::move(from);
  }

  inline ApexInfo& operator=(const ApexInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApexInfo& operator=(ApexInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApexInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApexInfo* internal_default_instance() {
    return reinterpret_cast<const ApexInfo*>(
               &_ApexInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ApexInfo& a, ApexInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ApexInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApexInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApexInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApexInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApexInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ApexInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApexInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chromeos_update_engine.ApexInfo";
  }
  protected:
  explicit ApexInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPackageNameFieldNumber = 1,
    kVersionFieldNumber = 2,
    kDecompressedSizeFieldNumber = 4,
    kIsCompressedFieldNumber = 3,
  };
  // optional string package_name = 1;
  bool has_package_name() const;
  private:
  bool _internal_has_package_name() const;
  public:
  void clear_package_name();
  const std::string& package_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_package_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_package_name();
  PROTOBUF_NODISCARD std::string* release_package_name();
  void set_allocated_package_name(std::string* package_name);
  private:
  const std::string& _internal_package_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package_name(const std::string& value);
  std::string* _internal_mutable_package_name();
  public:

  // optional int64 version = 2;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  int64_t version() const;
  void set_version(int64_t value);
  private:
  int64_t _internal_version() const;
  void _internal_set_version(int64_t value);
  public:

  // optional int64 decompressed_size = 4;
  bool has_decompressed_size() const;
  private:
  bool _internal_has_decompressed_size() const;
  public:
  void clear_decompressed_size();
  int64_t decompressed_size() const;
  void set_decompressed_size(int64_t value);
  private:
  int64_t _internal_decompressed_size() const;
  void _internal_set_decompressed_size(int64_t value);
  public:

  // optional bool is_compressed = 3;
  bool has_is_compressed() const;
  private:
  bool _internal_has_is_compressed() const;
  public:
  void clear_is_compressed();
  bool is_compressed() const;
  void set_is_compressed(bool value);
  private:
  bool _internal_is_compressed() const;
  void _internal_set_is_compressed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.ApexInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_name_;
  int64_t version_;
  int64_t decompressed_size_;
  bool is_compressed_;
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class ApexMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chromeos_update_engine.ApexMetadata) */ {
 public:
  inline ApexMetadata() : ApexMetadata(nullptr) {}
  ~ApexMetadata() override;
  explicit PROTOBUF_CONSTEXPR ApexMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApexMetadata(const ApexMetadata& from);
  ApexMetadata(ApexMetadata&& from) noexcept
    : ApexMetadata() {
    *this = ::std::move(from);
  }

  inline ApexMetadata& operator=(const ApexMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApexMetadata& operator=(ApexMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApexMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApexMetadata* internal_default_instance() {
    return reinterpret_cast<const ApexMetadata*>(
               &_ApexMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ApexMetadata& a, ApexMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(ApexMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApexMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApexMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApexMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApexMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ApexMetadata& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApexMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chromeos_update_engine.ApexMetadata";
  }
  protected:
  explicit ApexMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kApexInfoFieldNumber = 1,
  };
  // repeated .chromeos_update_engine.ApexInfo apex_info = 1;
  int apex_info_size() const;
  private:
  int _internal_apex_info_size() const;
  public:
  void clear_apex_info();
  ::chromeos_update_engine::ApexInfo* mutable_apex_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::ApexInfo >*
      mutable_apex_info();
  private:
  const ::chromeos_update_engine::ApexInfo& _internal_apex_info(int index) const;
  ::chromeos_update_engine::ApexInfo* _internal_add_apex_info();
  public:
  const ::chromeos_update_engine::ApexInfo& apex_info(int index) const;
  ::chromeos_update_engine::ApexInfo* add_apex_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::ApexInfo >&
      apex_info() const;

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.ApexMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::ApexInfo > apex_info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class DeltaArchiveManifest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chromeos_update_engine.DeltaArchiveManifest) */ {
 public:
  inline DeltaArchiveManifest() : DeltaArchiveManifest(nullptr) {}
  ~DeltaArchiveManifest() override;
  explicit PROTOBUF_CONSTEXPR DeltaArchiveManifest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeltaArchiveManifest(const DeltaArchiveManifest& from);
  DeltaArchiveManifest(DeltaArchiveManifest&& from) noexcept
    : DeltaArchiveManifest() {
    *this = ::std::move(from);
  }

  inline DeltaArchiveManifest& operator=(const DeltaArchiveManifest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeltaArchiveManifest& operator=(DeltaArchiveManifest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeltaArchiveManifest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeltaArchiveManifest* internal_default_instance() {
    return reinterpret_cast<const DeltaArchiveManifest*>(
               &_DeltaArchiveManifest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DeltaArchiveManifest& a, DeltaArchiveManifest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeltaArchiveManifest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeltaArchiveManifest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeltaArchiveManifest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeltaArchiveManifest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeltaArchiveManifest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeltaArchiveManifest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeltaArchiveManifest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chromeos_update_engine.DeltaArchiveManifest";
  }
  protected:
  explicit DeltaArchiveManifest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartitionsFieldNumber = 13,
    kApexInfoFieldNumber = 17,
    kSecurityPatchLevelFieldNumber = 18,
    kDynamicPartitionMetadataFieldNumber = 15,
    kSignaturesOffsetFieldNumber = 4,
    kSignaturesSizeFieldNumber = 5,
    kMaxTimestampFieldNumber = 14,
    kMinorVersionFieldNumber = 12,
    kPartialUpdateFieldNumber = 16,
    kBlockSizeFieldNumber = 3,
  };
  // repeated .chromeos_update_engine.PartitionUpdate partitions = 13;
  int partitions_size() const;
  private:
  int _internal_partitions_size() const;
  public:
  void clear_partitions();
  ::chromeos_update_engine::PartitionUpdate* mutable_partitions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::PartitionUpdate >*
      mutable_partitions();
  private:
  const ::chromeos_update_engine::PartitionUpdate& _internal_partitions(int index) const;
  ::chromeos_update_engine::PartitionUpdate* _internal_add_partitions();
  public:
  const ::chromeos_update_engine::PartitionUpdate& partitions(int index) const;
  ::chromeos_update_engine::PartitionUpdate* add_partitions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::PartitionUpdate >&
      partitions() const;

  // repeated .chromeos_update_engine.ApexInfo apex_info = 17;
  int apex_info_size() const;
  private:
  int _internal_apex_info_size() const;
  public:
  void clear_apex_info();
  ::chromeos_update_engine::ApexInfo* mutable_apex_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::ApexInfo >*
      mutable_apex_info();
  private:
  const ::chromeos_update_engine::ApexInfo& _internal_apex_info(int index) const;
  ::chromeos_update_engine::ApexInfo* _internal_add_apex_info();
  public:
  const ::chromeos_update_engine::ApexInfo& apex_info(int index) const;
  ::chromeos_update_engine::ApexInfo* add_apex_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::ApexInfo >&
      apex_info() const;

  // optional string security_patch_level = 18;
  bool has_security_patch_level() const;
  private:
  bool _internal_has_security_patch_level() const;
  public:
  void clear_security_patch_level();
  const std::string& security_patch_level() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_security_patch_level(ArgT0&& arg0, ArgT... args);
  std::string* mutable_security_patch_level();
  PROTOBUF_NODISCARD std::string* release_security_patch_level();
  void set_allocated_security_patch_level(std::string* security_patch_level);
  private:
  const std::string& _internal_security_patch_level() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_security_patch_level(const std::string& value);
  std::string* _internal_mutable_security_patch_level();
  public:

  // optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;
  bool has_dynamic_partition_metadata() const;
  private:
  bool _internal_has_dynamic_partition_metadata() const;
  public:
  void clear_dynamic_partition_metadata();
  const ::chromeos_update_engine::DynamicPartitionMetadata& dynamic_partition_metadata() const;
  PROTOBUF_NODISCARD ::chromeos_update_engine::DynamicPartitionMetadata* release_dynamic_partition_metadata();
  ::chromeos_update_engine::DynamicPartitionMetadata* mutable_dynamic_partition_metadata();
  void set_allocated_dynamic_partition_metadata(::chromeos_update_engine::DynamicPartitionMetadata* dynamic_partition_metadata);
  private:
  const ::chromeos_update_engine::DynamicPartitionMetadata& _internal_dynamic_partition_metadata() const;
  ::chromeos_update_engine::DynamicPartitionMetadata* _internal_mutable_dynamic_partition_metadata();
  public:
  void unsafe_arena_set_allocated_dynamic_partition_metadata(
      ::chromeos_update_engine::DynamicPartitionMetadata* dynamic_partition_metadata);
  ::chromeos_update_engine::DynamicPartitionMetadata* unsafe_arena_release_dynamic_partition_metadata();

  // optional uint64 signatures_offset = 4;
  bool has_signatures_offset() const;
  private:
  bool _internal_has_signatures_offset() const;
  public:
  void clear_signatures_offset();
  uint64_t signatures_offset() const;
  void set_signatures_offset(uint64_t value);
  private:
  uint64_t _internal_signatures_offset() const;
  void _internal_set_signatures_offset(uint64_t value);
  public:

  // optional uint64 signatures_size = 5;
  bool has_signatures_size() const;
  private:
  bool _internal_has_signatures_size() const;
  public:
  void clear_signatures_size();
  uint64_t signatures_size() const;
  void set_signatures_size(uint64_t value);
  private:
  uint64_t _internal_signatures_size() const;
  void _internal_set_signatures_size(uint64_t value);
  public:

  // optional int64 max_timestamp = 14;
  bool has_max_timestamp() const;
  private:
  bool _internal_has_max_timestamp() const;
  public:
  void clear_max_timestamp();
  int64_t max_timestamp() const;
  void set_max_timestamp(int64_t value);
  private:
  int64_t _internal_max_timestamp() const;
  void _internal_set_max_timestamp(int64_t value);
  public:

  // optional uint32 minor_version = 12 [default = 0];
  bool has_minor_version() const;
  private:
  bool _internal_has_minor_version() const;
  public:
  void clear_minor_version();
  uint32_t minor_version() const;
  void set_minor_version(uint32_t value);
  private:
  uint32_t _internal_minor_version() const;
  void _internal_set_minor_version(uint32_t value);
  public:

  // optional bool partial_update = 16;
  bool has_partial_update() const;
  private:
  bool _internal_has_partial_update() const;
  public:
  void clear_partial_update();
  bool partial_update() const;
  void set_partial_update(bool value);
  private:
  bool _internal_partial_update() const;
  void _internal_set_partial_update(bool value);
  public:

  // optional uint32 block_size = 3 [default = 4096];
  bool has_block_size() const;
  private:
  bool _internal_has_block_size() const;
  public:
  void clear_block_size();
  uint32_t block_size() const;
  void set_block_size(uint32_t value);
  private:
  uint32_t _internal_block_size() const;
  void _internal_set_block_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.DeltaArchiveManifest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::PartitionUpdate > partitions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::ApexInfo > apex_info_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr security_patch_level_;
  ::chromeos_update_engine::DynamicPartitionMetadata* dynamic_partition_metadata_;
  uint64_t signatures_offset_;
  uint64_t signatures_size_;
  int64_t max_timestamp_;
  uint32_t minor_version_;
  bool partial_update_;
  uint32_t block_size_;
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Extent

// optional uint64 start_block = 1;
inline bool Extent::_internal_has_start_block() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Extent::has_start_block() const {
  return _internal_has_start_block();
}
inline void Extent::clear_start_block() {
  start_block_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t Extent::_internal_start_block() const {
  return start_block_;
}
inline uint64_t Extent::start_block() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.Extent.start_block)
  return _internal_start_block();
}
inline void Extent::_internal_set_start_block(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  start_block_ = value;
}
inline void Extent::set_start_block(uint64_t value) {
  _internal_set_start_block(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.Extent.start_block)
}

// optional uint64 num_blocks = 2;
inline bool Extent::_internal_has_num_blocks() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Extent::has_num_blocks() const {
  return _internal_has_num_blocks();
}
inline void Extent::clear_num_blocks() {
  num_blocks_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t Extent::_internal_num_blocks() const {
  return num_blocks_;
}
inline uint64_t Extent::num_blocks() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.Extent.num_blocks)
  return _internal_num_blocks();
}
inline void Extent::_internal_set_num_blocks(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  num_blocks_ = value;
}
inline void Extent::set_num_blocks(uint64_t value) {
  _internal_set_num_blocks(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.Extent.num_blocks)
}

// -------------------------------------------------------------------

// Signatures_Signature

// optional uint32 version = 1 [deprecated = true];
inline bool Signatures_Signature::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Signatures_Signature::has_version() const {
  return _internal_has_version();
}
inline void Signatures_Signature::clear_version() {
  version_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t Signatures_Signature::_internal_version() const {
  return version_;
}
inline uint32_t Signatures_Signature::version() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.Signatures.Signature.version)
  return _internal_version();
}
inline void Signatures_Signature::_internal_set_version(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  version_ = value;
}
inline void Signatures_Signature::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.Signatures.Signature.version)
}

// optional bytes data = 2;
inline bool Signatures_Signature::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Signatures_Signature::has_data() const {
  return _internal_has_data();
}
inline void Signatures_Signature::clear_data() {
  data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Signatures_Signature::data() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.Signatures.Signature.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Signatures_Signature::set_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chromeos_update_engine.Signatures.Signature.data)
}
inline std::string* Signatures_Signature::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.Signatures.Signature.data)
  return _s;
}
inline const std::string& Signatures_Signature::_internal_data() const {
  return data_.Get();
}
inline void Signatures_Signature::_internal_set_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.Set(value, GetArenaForAllocation());
}
inline std::string* Signatures_Signature::_internal_mutable_data() {
  _has_bits_[0] |= 0x00000001u;
  return data_.Mutable(GetArenaForAllocation());
}
inline std::string* Signatures_Signature::release_data() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.Signatures.Signature.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault()) {
    data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Signatures_Signature::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault()) {
    data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.Signatures.Signature.data)
}

// optional fixed32 unpadded_signature_size = 3;
inline bool Signatures_Signature::_internal_has_unpadded_signature_size() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Signatures_Signature::has_unpadded_signature_size() const {
  return _internal_has_unpadded_signature_size();
}
inline void Signatures_Signature::clear_unpadded_signature_size() {
  unpadded_signature_size_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t Signatures_Signature::_internal_unpadded_signature_size() const {
  return unpadded_signature_size_;
}
inline uint32_t Signatures_Signature::unpadded_signature_size() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.Signatures.Signature.unpadded_signature_size)
  return _internal_unpadded_signature_size();
}
inline void Signatures_Signature::_internal_set_unpadded_signature_size(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  unpadded_signature_size_ = value;
}
inline void Signatures_Signature::set_unpadded_signature_size(uint32_t value) {
  _internal_set_unpadded_signature_size(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.Signatures.Signature.unpadded_signature_size)
}

// -------------------------------------------------------------------

// Signatures

// repeated .chromeos_update_engine.Signatures.Signature signatures = 1;
inline int Signatures::_internal_signatures_size() const {
  return signatures_.size();
}
inline int Signatures::signatures_size() const {
  return _internal_signatures_size();
}
inline void Signatures::clear_signatures() {
  signatures_.Clear();
}
inline ::chromeos_update_engine::Signatures_Signature* Signatures::mutable_signatures(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.Signatures.signatures)
  return signatures_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature >*
Signatures::mutable_signatures() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.Signatures.signatures)
  return &signatures_;
}
inline const ::chromeos_update_engine::Signatures_Signature& Signatures::_internal_signatures(int index) const {
  return signatures_.Get(index);
}
inline const ::chromeos_update_engine::Signatures_Signature& Signatures::signatures(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.Signatures.signatures)
  return _internal_signatures(index);
}
inline ::chromeos_update_engine::Signatures_Signature* Signatures::_internal_add_signatures() {
  return signatures_.Add();
}
inline ::chromeos_update_engine::Signatures_Signature* Signatures::add_signatures() {
  ::chromeos_update_engine::Signatures_Signature* _add = _internal_add_signatures();
  // @@protoc_insertion_point(field_add:chromeos_update_engine.Signatures.signatures)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature >&
Signatures::signatures() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.Signatures.signatures)
  return signatures_;
}

// -------------------------------------------------------------------

// PartitionInfo

// optional uint64 size = 1;
inline bool PartitionInfo::_internal_has_size() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PartitionInfo::has_size() const {
  return _internal_has_size();
}
inline void PartitionInfo::clear_size() {
  size_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t PartitionInfo::_internal_size() const {
  return size_;
}
inline uint64_t PartitionInfo::size() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionInfo.size)
  return _internal_size();
}
inline void PartitionInfo::_internal_set_size(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  size_ = value;
}
inline void PartitionInfo::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionInfo.size)
}

// optional bytes hash = 2;
inline bool PartitionInfo::_internal_has_hash() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PartitionInfo::has_hash() const {
  return _internal_has_hash();
}
inline void PartitionInfo::clear_hash() {
  hash_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PartitionInfo::hash() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionInfo.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartitionInfo::set_hash(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionInfo.hash)
}
inline std::string* PartitionInfo::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionInfo.hash)
  return _s;
}
inline const std::string& PartitionInfo::_internal_hash() const {
  return hash_.Get();
}
inline void PartitionInfo::_internal_set_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  hash_.Set(value, GetArenaForAllocation());
}
inline std::string* PartitionInfo::_internal_mutable_hash() {
  _has_bits_[0] |= 0x00000001u;
  return hash_.Mutable(GetArenaForAllocation());
}
inline std::string* PartitionInfo::release_hash() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionInfo.hash)
  if (!_internal_has_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = hash_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hash_.IsDefault()) {
    hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PartitionInfo::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  hash_.SetAllocated(hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hash_.IsDefault()) {
    hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionInfo.hash)
}

// -------------------------------------------------------------------

// InstallOperation

// required .chromeos_update_engine.InstallOperation.Type type = 1;
inline bool InstallOperation::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool InstallOperation::has_type() const {
  return _internal_has_type();
}
inline void InstallOperation::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::chromeos_update_engine::InstallOperation_Type InstallOperation::_internal_type() const {
  return static_cast< ::chromeos_update_engine::InstallOperation_Type >(type_);
}
inline ::chromeos_update_engine::InstallOperation_Type InstallOperation::type() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.type)
  return _internal_type();
}
inline void InstallOperation::_internal_set_type(::chromeos_update_engine::InstallOperation_Type value) {
  assert(::chromeos_update_engine::InstallOperation_Type_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  type_ = value;
}
inline void InstallOperation::set_type(::chromeos_update_engine::InstallOperation_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.type)
}

// optional uint64 data_offset = 2;
inline bool InstallOperation::_internal_has_data_offset() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool InstallOperation::has_data_offset() const {
  return _internal_has_data_offset();
}
inline void InstallOperation::clear_data_offset() {
  data_offset_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t InstallOperation::_internal_data_offset() const {
  return data_offset_;
}
inline uint64_t InstallOperation::data_offset() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.data_offset)
  return _internal_data_offset();
}
inline void InstallOperation::_internal_set_data_offset(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  data_offset_ = value;
}
inline void InstallOperation::set_data_offset(uint64_t value) {
  _internal_set_data_offset(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.data_offset)
}

// optional uint64 data_length = 3;
inline bool InstallOperation::_internal_has_data_length() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool InstallOperation::has_data_length() const {
  return _internal_has_data_length();
}
inline void InstallOperation::clear_data_length() {
  data_length_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline uint64_t InstallOperation::_internal_data_length() const {
  return data_length_;
}
inline uint64_t InstallOperation::data_length() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.data_length)
  return _internal_data_length();
}
inline void InstallOperation::_internal_set_data_length(uint64_t value) {
  _has_bits_[0] |= 0x00000008u;
  data_length_ = value;
}
inline void InstallOperation::set_data_length(uint64_t value) {
  _internal_set_data_length(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.data_length)
}

// repeated .chromeos_update_engine.Extent src_extents = 4;
inline int InstallOperation::_internal_src_extents_size() const {
  return src_extents_.size();
}
inline int InstallOperation::src_extents_size() const {
  return _internal_src_extents_size();
}
inline void InstallOperation::clear_src_extents() {
  src_extents_.Clear();
}
inline ::chromeos_update_engine::Extent* InstallOperation::mutable_src_extents(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.InstallOperation.src_extents)
  return src_extents_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Extent >*
InstallOperation::mutable_src_extents() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.InstallOperation.src_extents)
  return &src_extents_;
}
inline const ::chromeos_update_engine::Extent& InstallOperation::_internal_src_extents(int index) const {
  return src_extents_.Get(index);
}
inline const ::chromeos_update_engine::Extent& InstallOperation::src_extents(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.src_extents)
  return _internal_src_extents(index);
}
inline ::chromeos_update_engine::Extent* InstallOperation::_internal_add_src_extents() {
  return src_extents_.Add();
}
inline ::chromeos_update_engine::Extent* InstallOperation::add_src_extents() {
  ::chromeos_update_engine::Extent* _add = _internal_add_src_extents();
  // @@protoc_insertion_point(field_add:chromeos_update_engine.InstallOperation.src_extents)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Extent >&
InstallOperation::src_extents() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.InstallOperation.src_extents)
  return src_extents_;
}

// optional uint64 src_length = 5;
inline bool InstallOperation::_internal_has_src_length() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool InstallOperation::has_src_length() const {
  return _internal_has_src_length();
}
inline void InstallOperation::clear_src_length() {
  src_length_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000010u;
}
inline uint64_t InstallOperation::_internal_src_length() const {
  return src_length_;
}
inline uint64_t InstallOperation::src_length() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.src_length)
  return _internal_src_length();
}
inline void InstallOperation::_internal_set_src_length(uint64_t value) {
  _has_bits_[0] |= 0x00000010u;
  src_length_ = value;
}
inline void InstallOperation::set_src_length(uint64_t value) {
  _internal_set_src_length(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.src_length)
}

// repeated .chromeos_update_engine.Extent dst_extents = 6;
inline int InstallOperation::_internal_dst_extents_size() const {
  return dst_extents_.size();
}
inline int InstallOperation::dst_extents_size() const {
  return _internal_dst_extents_size();
}
inline void InstallOperation::clear_dst_extents() {
  dst_extents_.Clear();
}
inline ::chromeos_update_engine::Extent* InstallOperation::mutable_dst_extents(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.InstallOperation.dst_extents)
  return dst_extents_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Extent >*
InstallOperation::mutable_dst_extents() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.InstallOperation.dst_extents)
  return &dst_extents_;
}
inline const ::chromeos_update_engine::Extent& InstallOperation::_internal_dst_extents(int index) const {
  return dst_extents_.Get(index);
}
inline const ::chromeos_update_engine::Extent& InstallOperation::dst_extents(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.dst_extents)
  return _internal_dst_extents(index);
}
inline ::chromeos_update_engine::Extent* InstallOperation::_internal_add_dst_extents() {
  return dst_extents_.Add();
}
inline ::chromeos_update_engine::Extent* InstallOperation::add_dst_extents() {
  ::chromeos_update_engine::Extent* _add = _internal_add_dst_extents();
  // @@protoc_insertion_point(field_add:chromeos_update_engine.InstallOperation.dst_extents)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Extent >&
InstallOperation::dst_extents() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.InstallOperation.dst_extents)
  return dst_extents_;
}

// optional uint64 dst_length = 7;
inline bool InstallOperation::_internal_has_dst_length() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool InstallOperation::has_dst_length() const {
  return _internal_has_dst_length();
}
inline void InstallOperation::clear_dst_length() {
  dst_length_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000020u;
}
inline uint64_t InstallOperation::_internal_dst_length() const {
  return dst_length_;
}
inline uint64_t InstallOperation::dst_length() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.dst_length)
  return _internal_dst_length();
}
inline void InstallOperation::_internal_set_dst_length(uint64_t value) {
  _has_bits_[0] |= 0x00000020u;
  dst_length_ = value;
}
inline void InstallOperation::set_dst_length(uint64_t value) {
  _internal_set_dst_length(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.dst_length)
}

// optional bytes data_sha256_hash = 8;
inline bool InstallOperation::_internal_has_data_sha256_hash() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InstallOperation::has_data_sha256_hash() const {
  return _internal_has_data_sha256_hash();
}
inline void InstallOperation::clear_data_sha256_hash() {
  data_sha256_hash_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InstallOperation::data_sha256_hash() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.data_sha256_hash)
  return _internal_data_sha256_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstallOperation::set_data_sha256_hash(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 data_sha256_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.data_sha256_hash)
}
inline std::string* InstallOperation::mutable_data_sha256_hash() {
  std::string* _s = _internal_mutable_data_sha256_hash();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.InstallOperation.data_sha256_hash)
  return _s;
}
inline const std::string& InstallOperation::_internal_data_sha256_hash() const {
  return data_sha256_hash_.Get();
}
inline void InstallOperation::_internal_set_data_sha256_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data_sha256_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* InstallOperation::_internal_mutable_data_sha256_hash() {
  _has_bits_[0] |= 0x00000001u;
  return data_sha256_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* InstallOperation::release_data_sha256_hash() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.InstallOperation.data_sha256_hash)
  if (!_internal_has_data_sha256_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = data_sha256_hash_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_sha256_hash_.IsDefault()) {
    data_sha256_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InstallOperation::set_allocated_data_sha256_hash(std::string* data_sha256_hash) {
  if (data_sha256_hash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_sha256_hash_.SetAllocated(data_sha256_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_sha256_hash_.IsDefault()) {
    data_sha256_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.InstallOperation.data_sha256_hash)
}

// optional bytes src_sha256_hash = 9;
inline bool InstallOperation::_internal_has_src_sha256_hash() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InstallOperation::has_src_sha256_hash() const {
  return _internal_has_src_sha256_hash();
}
inline void InstallOperation::clear_src_sha256_hash() {
  src_sha256_hash_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InstallOperation::src_sha256_hash() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.src_sha256_hash)
  return _internal_src_sha256_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstallOperation::set_src_sha256_hash(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 src_sha256_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.src_sha256_hash)
}
inline std::string* InstallOperation::mutable_src_sha256_hash() {
  std::string* _s = _internal_mutable_src_sha256_hash();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.InstallOperation.src_sha256_hash)
  return _s;
}
inline const std::string& InstallOperation::_internal_src_sha256_hash() const {
  return src_sha256_hash_.Get();
}
inline void InstallOperation::_internal_set_src_sha256_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  src_sha256_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* InstallOperation::_internal_mutable_src_sha256_hash() {
  _has_bits_[0] |= 0x00000002u;
  return src_sha256_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* InstallOperation::release_src_sha256_hash() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.InstallOperation.src_sha256_hash)
  if (!_internal_has_src_sha256_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = src_sha256_hash_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (src_sha256_hash_.IsDefault()) {
    src_sha256_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InstallOperation::set_allocated_src_sha256_hash(std::string* src_sha256_hash) {
  if (src_sha256_hash != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  src_sha256_hash_.SetAllocated(src_sha256_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (src_sha256_hash_.IsDefault()) {
    src_sha256_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.InstallOperation.src_sha256_hash)
}

// -------------------------------------------------------------------

// CowMergeOperation

// optional .chromeos_update_engine.CowMergeOperation.Type type = 1;
inline bool CowMergeOperation::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CowMergeOperation::has_type() const {
  return _internal_has_type();
}
inline void CowMergeOperation::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::chromeos_update_engine::CowMergeOperation_Type CowMergeOperation::_internal_type() const {
  return static_cast< ::chromeos_update_engine::CowMergeOperation_Type >(type_);
}
inline ::chromeos_update_engine::CowMergeOperation_Type CowMergeOperation::type() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.CowMergeOperation.type)
  return _internal_type();
}
inline void CowMergeOperation::_internal_set_type(::chromeos_update_engine::CowMergeOperation_Type value) {
  assert(::chromeos_update_engine::CowMergeOperation_Type_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
}
inline void CowMergeOperation::set_type(::chromeos_update_engine::CowMergeOperation_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.CowMergeOperation.type)
}

// optional .chromeos_update_engine.Extent src_extent = 2;
inline bool CowMergeOperation::_internal_has_src_extent() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || src_extent_ != nullptr);
  return value;
}
inline bool CowMergeOperation::has_src_extent() const {
  return _internal_has_src_extent();
}
inline void CowMergeOperation::clear_src_extent() {
  if (src_extent_ != nullptr) src_extent_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::chromeos_update_engine::Extent& CowMergeOperation::_internal_src_extent() const {
  const ::chromeos_update_engine::Extent* p = src_extent_;
  return p != nullptr ? *p : reinterpret_cast<const ::chromeos_update_engine::Extent&>(
      ::chromeos_update_engine::_Extent_default_instance_);
}
inline const ::chromeos_update_engine::Extent& CowMergeOperation::src_extent() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.CowMergeOperation.src_extent)
  return _internal_src_extent();
}
inline void CowMergeOperation::unsafe_arena_set_allocated_src_extent(
    ::chromeos_update_engine::Extent* src_extent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(src_extent_);
  }
  src_extent_ = src_extent;
  if (src_extent) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chromeos_update_engine.CowMergeOperation.src_extent)
}
inline ::chromeos_update_engine::Extent* CowMergeOperation::release_src_extent() {
  _has_bits_[0] &= ~0x00000001u;
  ::chromeos_update_engine::Extent* temp = src_extent_;
  src_extent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chromeos_update_engine::Extent* CowMergeOperation::unsafe_arena_release_src_extent() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.CowMergeOperation.src_extent)
  _has_bits_[0] &= ~0x00000001u;
  ::chromeos_update_engine::Extent* temp = src_extent_;
  src_extent_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::Extent* CowMergeOperation::_internal_mutable_src_extent() {
  _has_bits_[0] |= 0x00000001u;
  if (src_extent_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::Extent>(GetArenaForAllocation());
    src_extent_ = p;
  }
  return src_extent_;
}
inline ::chromeos_update_engine::Extent* CowMergeOperation::mutable_src_extent() {
  ::chromeos_update_engine::Extent* _msg = _internal_mutable_src_extent();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.CowMergeOperation.src_extent)
  return _msg;
}
inline void CowMergeOperation::set_allocated_src_extent(::chromeos_update_engine::Extent* src_extent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete src_extent_;
  }
  if (src_extent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(src_extent);
    if (message_arena != submessage_arena) {
      src_extent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, src_extent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  src_extent_ = src_extent;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.CowMergeOperation.src_extent)
}

// optional .chromeos_update_engine.Extent dst_extent = 3;
inline bool CowMergeOperation::_internal_has_dst_extent() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || dst_extent_ != nullptr);
  return value;
}
inline bool CowMergeOperation::has_dst_extent() const {
  return _internal_has_dst_extent();
}
inline void CowMergeOperation::clear_dst_extent() {
  if (dst_extent_ != nullptr) dst_extent_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::chromeos_update_engine::Extent& CowMergeOperation::_internal_dst_extent() const {
  const ::chromeos_update_engine::Extent* p = dst_extent_;
  return p != nullptr ? *p : reinterpret_cast<const ::chromeos_update_engine::Extent&>(
      ::chromeos_update_engine::_Extent_default_instance_);
}
inline const ::chromeos_update_engine::Extent& CowMergeOperation::dst_extent() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.CowMergeOperation.dst_extent)
  return _internal_dst_extent();
}
inline void CowMergeOperation::unsafe_arena_set_allocated_dst_extent(
    ::chromeos_update_engine::Extent* dst_extent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dst_extent_);
  }
  dst_extent_ = dst_extent;
  if (dst_extent) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chromeos_update_engine.CowMergeOperation.dst_extent)
}
inline ::chromeos_update_engine::Extent* CowMergeOperation::release_dst_extent() {
  _has_bits_[0] &= ~0x00000002u;
  ::chromeos_update_engine::Extent* temp = dst_extent_;
  dst_extent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chromeos_update_engine::Extent* CowMergeOperation::unsafe_arena_release_dst_extent() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.CowMergeOperation.dst_extent)
  _has_bits_[0] &= ~0x00000002u;
  ::chromeos_update_engine::Extent* temp = dst_extent_;
  dst_extent_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::Extent* CowMergeOperation::_internal_mutable_dst_extent() {
  _has_bits_[0] |= 0x00000002u;
  if (dst_extent_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::Extent>(GetArenaForAllocation());
    dst_extent_ = p;
  }
  return dst_extent_;
}
inline ::chromeos_update_engine::Extent* CowMergeOperation::mutable_dst_extent() {
  ::chromeos_update_engine::Extent* _msg = _internal_mutable_dst_extent();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.CowMergeOperation.dst_extent)
  return _msg;
}
inline void CowMergeOperation::set_allocated_dst_extent(::chromeos_update_engine::Extent* dst_extent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dst_extent_;
  }
  if (dst_extent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dst_extent);
    if (message_arena != submessage_arena) {
      dst_extent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dst_extent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  dst_extent_ = dst_extent;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.CowMergeOperation.dst_extent)
}

// optional uint32 src_offset = 4;
inline bool CowMergeOperation::_internal_has_src_offset() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CowMergeOperation::has_src_offset() const {
  return _internal_has_src_offset();
}
inline void CowMergeOperation::clear_src_offset() {
  src_offset_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CowMergeOperation::_internal_src_offset() const {
  return src_offset_;
}
inline uint32_t CowMergeOperation::src_offset() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.CowMergeOperation.src_offset)
  return _internal_src_offset();
}
inline void CowMergeOperation::_internal_set_src_offset(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  src_offset_ = value;
}
inline void CowMergeOperation::set_src_offset(uint32_t value) {
  _internal_set_src_offset(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.CowMergeOperation.src_offset)
}

// -------------------------------------------------------------------

// PartitionUpdate

// required string partition_name = 1;
inline bool PartitionUpdate::_internal_has_partition_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PartitionUpdate::has_partition_name() const {
  return _internal_has_partition_name();
}
inline void PartitionUpdate::clear_partition_name() {
  partition_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PartitionUpdate::partition_name() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.partition_name)
  return _internal_partition_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartitionUpdate::set_partition_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 partition_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.partition_name)
}
inline std::string* PartitionUpdate::mutable_partition_name() {
  std::string* _s = _internal_mutable_partition_name();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.partition_name)
  return _s;
}
inline const std::string& PartitionUpdate::_internal_partition_name() const {
  return partition_name_.Get();
}
inline void PartitionUpdate::_internal_set_partition_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  partition_name_.Set(value, GetArenaForAllocation());
}
inline std::string* PartitionUpdate::_internal_mutable_partition_name() {
  _has_bits_[0] |= 0x00000001u;
  return partition_name_.Mutable(GetArenaForAllocation());
}
inline std::string* PartitionUpdate::release_partition_name() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.partition_name)
  if (!_internal_has_partition_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = partition_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (partition_name_.IsDefault()) {
    partition_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PartitionUpdate::set_allocated_partition_name(std::string* partition_name) {
  if (partition_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  partition_name_.SetAllocated(partition_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (partition_name_.IsDefault()) {
    partition_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.partition_name)
}

// optional bool run_postinstall = 2;
inline bool PartitionUpdate::_internal_has_run_postinstall() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool PartitionUpdate::has_run_postinstall() const {
  return _internal_has_run_postinstall();
}
inline void PartitionUpdate::clear_run_postinstall() {
  run_postinstall_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool PartitionUpdate::_internal_run_postinstall() const {
  return run_postinstall_;
}
inline bool PartitionUpdate::run_postinstall() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.run_postinstall)
  return _internal_run_postinstall();
}
inline void PartitionUpdate::_internal_set_run_postinstall(bool value) {
  _has_bits_[0] |= 0x00004000u;
  run_postinstall_ = value;
}
inline void PartitionUpdate::set_run_postinstall(bool value) {
  _internal_set_run_postinstall(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.run_postinstall)
}

// optional string postinstall_path = 3;
inline bool PartitionUpdate::_internal_has_postinstall_path() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PartitionUpdate::has_postinstall_path() const {
  return _internal_has_postinstall_path();
}
inline void PartitionUpdate::clear_postinstall_path() {
  postinstall_path_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PartitionUpdate::postinstall_path() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.postinstall_path)
  return _internal_postinstall_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartitionUpdate::set_postinstall_path(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 postinstall_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.postinstall_path)
}
inline std::string* PartitionUpdate::mutable_postinstall_path() {
  std::string* _s = _internal_mutable_postinstall_path();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.postinstall_path)
  return _s;
}
inline const std::string& PartitionUpdate::_internal_postinstall_path() const {
  return postinstall_path_.Get();
}
inline void PartitionUpdate::_internal_set_postinstall_path(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  postinstall_path_.Set(value, GetArenaForAllocation());
}
inline std::string* PartitionUpdate::_internal_mutable_postinstall_path() {
  _has_bits_[0] |= 0x00000002u;
  return postinstall_path_.Mutable(GetArenaForAllocation());
}
inline std::string* PartitionUpdate::release_postinstall_path() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.postinstall_path)
  if (!_internal_has_postinstall_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = postinstall_path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (postinstall_path_.IsDefault()) {
    postinstall_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PartitionUpdate::set_allocated_postinstall_path(std::string* postinstall_path) {
  if (postinstall_path != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  postinstall_path_.SetAllocated(postinstall_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (postinstall_path_.IsDefault()) {
    postinstall_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.postinstall_path)
}

// optional string filesystem_type = 4;
inline bool PartitionUpdate::_internal_has_filesystem_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PartitionUpdate::has_filesystem_type() const {
  return _internal_has_filesystem_type();
}
inline void PartitionUpdate::clear_filesystem_type() {
  filesystem_type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PartitionUpdate::filesystem_type() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.filesystem_type)
  return _internal_filesystem_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartitionUpdate::set_filesystem_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 filesystem_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.filesystem_type)
}
inline std::string* PartitionUpdate::mutable_filesystem_type() {
  std::string* _s = _internal_mutable_filesystem_type();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.filesystem_type)
  return _s;
}
inline const std::string& PartitionUpdate::_internal_filesystem_type() const {
  return filesystem_type_.Get();
}
inline void PartitionUpdate::_internal_set_filesystem_type(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  filesystem_type_.Set(value, GetArenaForAllocation());
}
inline std::string* PartitionUpdate::_internal_mutable_filesystem_type() {
  _has_bits_[0] |= 0x00000004u;
  return filesystem_type_.Mutable(GetArenaForAllocation());
}
inline std::string* PartitionUpdate::release_filesystem_type() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.filesystem_type)
  if (!_internal_has_filesystem_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = filesystem_type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filesystem_type_.IsDefault()) {
    filesystem_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PartitionUpdate::set_allocated_filesystem_type(std::string* filesystem_type) {
  if (filesystem_type != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  filesystem_type_.SetAllocated(filesystem_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filesystem_type_.IsDefault()) {
    filesystem_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.filesystem_type)
}

// repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;
inline int PartitionUpdate::_internal_new_partition_signature_size() const {
  return new_partition_signature_.size();
}
inline int PartitionUpdate::new_partition_signature_size() const {
  return _internal_new_partition_signature_size();
}
inline void PartitionUpdate::clear_new_partition_signature() {
  new_partition_signature_.Clear();
}
inline ::chromeos_update_engine::Signatures_Signature* PartitionUpdate::mutable_new_partition_signature(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.new_partition_signature)
  return new_partition_signature_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature >*
PartitionUpdate::mutable_new_partition_signature() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.PartitionUpdate.new_partition_signature)
  return &new_partition_signature_;
}
inline const ::chromeos_update_engine::Signatures_Signature& PartitionUpdate::_internal_new_partition_signature(int index) const {
  return new_partition_signature_.Get(index);
}
inline const ::chromeos_update_engine::Signatures_Signature& PartitionUpdate::new_partition_signature(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.new_partition_signature)
  return _internal_new_partition_signature(index);
}
inline ::chromeos_update_engine::Signatures_Signature* PartitionUpdate::_internal_add_new_partition_signature() {
  return new_partition_signature_.Add();
}
inline ::chromeos_update_engine::Signatures_Signature* PartitionUpdate::add_new_partition_signature() {
  ::chromeos_update_engine::Signatures_Signature* _add = _internal_add_new_partition_signature();
  // @@protoc_insertion_point(field_add:chromeos_update_engine.PartitionUpdate.new_partition_signature)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature >&
PartitionUpdate::new_partition_signature() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.PartitionUpdate.new_partition_signature)
  return new_partition_signature_;
}

// optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;
inline bool PartitionUpdate::_internal_has_old_partition_info() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || old_partition_info_ != nullptr);
  return value;
}
inline bool PartitionUpdate::has_old_partition_info() const {
  return _internal_has_old_partition_info();
}
inline void PartitionUpdate::clear_old_partition_info() {
  if (old_partition_info_ != nullptr) old_partition_info_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::chromeos_update_engine::PartitionInfo& PartitionUpdate::_internal_old_partition_info() const {
  const ::chromeos_update_engine::PartitionInfo* p = old_partition_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::chromeos_update_engine::PartitionInfo&>(
      ::chromeos_update_engine::_PartitionInfo_default_instance_);
}
inline const ::chromeos_update_engine::PartitionInfo& PartitionUpdate::old_partition_info() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.old_partition_info)
  return _internal_old_partition_info();
}
inline void PartitionUpdate::unsafe_arena_set_allocated_old_partition_info(
    ::chromeos_update_engine::PartitionInfo* old_partition_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(old_partition_info_);
  }
  old_partition_info_ = old_partition_info;
  if (old_partition_info) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chromeos_update_engine.PartitionUpdate.old_partition_info)
}
inline ::chromeos_update_engine::PartitionInfo* PartitionUpdate::release_old_partition_info() {
  _has_bits_[0] &= ~0x00000040u;
  ::chromeos_update_engine::PartitionInfo* temp = old_partition_info_;
  old_partition_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chromeos_update_engine::PartitionInfo* PartitionUpdate::unsafe_arena_release_old_partition_info() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.old_partition_info)
  _has_bits_[0] &= ~0x00000040u;
  ::chromeos_update_engine::PartitionInfo* temp = old_partition_info_;
  old_partition_info_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::PartitionInfo* PartitionUpdate::_internal_mutable_old_partition_info() {
  _has_bits_[0] |= 0x00000040u;
  if (old_partition_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::PartitionInfo>(GetArenaForAllocation());
    old_partition_info_ = p;
  }
  return old_partition_info_;
}
inline ::chromeos_update_engine::PartitionInfo* PartitionUpdate::mutable_old_partition_info() {
  ::chromeos_update_engine::PartitionInfo* _msg = _internal_mutable_old_partition_info();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.old_partition_info)
  return _msg;
}
inline void PartitionUpdate::set_allocated_old_partition_info(::chromeos_update_engine::PartitionInfo* old_partition_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete old_partition_info_;
  }
  if (old_partition_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(old_partition_info);
    if (message_arena != submessage_arena) {
      old_partition_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, old_partition_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  old_partition_info_ = old_partition_info;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.old_partition_info)
}

// optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;
inline bool PartitionUpdate::_internal_has_new_partition_info() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || new_partition_info_ != nullptr);
  return value;
}
inline bool PartitionUpdate::has_new_partition_info() const {
  return _internal_has_new_partition_info();
}
inline void PartitionUpdate::clear_new_partition_info() {
  if (new_partition_info_ != nullptr) new_partition_info_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::chromeos_update_engine::PartitionInfo& PartitionUpdate::_internal_new_partition_info() const {
  const ::chromeos_update_engine::PartitionInfo* p = new_partition_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::chromeos_update_engine::PartitionInfo&>(
      ::chromeos_update_engine::_PartitionInfo_default_instance_);
}
inline const ::chromeos_update_engine::PartitionInfo& PartitionUpdate::new_partition_info() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.new_partition_info)
  return _internal_new_partition_info();
}
inline void PartitionUpdate::unsafe_arena_set_allocated_new_partition_info(
    ::chromeos_update_engine::PartitionInfo* new_partition_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(new_partition_info_);
  }
  new_partition_info_ = new_partition_info;
  if (new_partition_info) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chromeos_update_engine.PartitionUpdate.new_partition_info)
}
inline ::chromeos_update_engine::PartitionInfo* PartitionUpdate::release_new_partition_info() {
  _has_bits_[0] &= ~0x00000080u;
  ::chromeos_update_engine::PartitionInfo* temp = new_partition_info_;
  new_partition_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chromeos_update_engine::PartitionInfo* PartitionUpdate::unsafe_arena_release_new_partition_info() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.new_partition_info)
  _has_bits_[0] &= ~0x00000080u;
  ::chromeos_update_engine::PartitionInfo* temp = new_partition_info_;
  new_partition_info_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::PartitionInfo* PartitionUpdate::_internal_mutable_new_partition_info() {
  _has_bits_[0] |= 0x00000080u;
  if (new_partition_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::PartitionInfo>(GetArenaForAllocation());
    new_partition_info_ = p;
  }
  return new_partition_info_;
}
inline ::chromeos_update_engine::PartitionInfo* PartitionUpdate::mutable_new_partition_info() {
  ::chromeos_update_engine::PartitionInfo* _msg = _internal_mutable_new_partition_info();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.new_partition_info)
  return _msg;
}
inline void PartitionUpdate::set_allocated_new_partition_info(::chromeos_update_engine::PartitionInfo* new_partition_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete new_partition_info_;
  }
  if (new_partition_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(new_partition_info);
    if (message_arena != submessage_arena) {
      new_partition_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, new_partition_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  new_partition_info_ = new_partition_info;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.new_partition_info)
}

// repeated .chromeos_update_engine.InstallOperation operations = 8;
inline int PartitionUpdate::_internal_operations_size() const {
  return operations_.size();
}
inline int PartitionUpdate::operations_size() const {
  return _internal_operations_size();
}
inline void PartitionUpdate::clear_operations() {
  operations_.Clear();
}
inline ::chromeos_update_engine::InstallOperation* PartitionUpdate::mutable_operations(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.operations)
  return operations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::InstallOperation >*
PartitionUpdate::mutable_operations() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.PartitionUpdate.operations)
  return &operations_;
}
inline const ::chromeos_update_engine::InstallOperation& PartitionUpdate::_internal_operations(int index) const {
  return operations_.Get(index);
}
inline const ::chromeos_update_engine::InstallOperation& PartitionUpdate::operations(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.operations)
  return _internal_operations(index);
}
inline ::chromeos_update_engine::InstallOperation* PartitionUpdate::_internal_add_operations() {
  return operations_.Add();
}
inline ::chromeos_update_engine::InstallOperation* PartitionUpdate::add_operations() {
  ::chromeos_update_engine::InstallOperation* _add = _internal_add_operations();
  // @@protoc_insertion_point(field_add:chromeos_update_engine.PartitionUpdate.operations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::InstallOperation >&
PartitionUpdate::operations() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.PartitionUpdate.operations)
  return operations_;
}

// optional bool postinstall_optional = 9;
inline bool PartitionUpdate::_internal_has_postinstall_optional() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool PartitionUpdate::has_postinstall_optional() const {
  return _internal_has_postinstall_optional();
}
inline void PartitionUpdate::clear_postinstall_optional() {
  postinstall_optional_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool PartitionUpdate::_internal_postinstall_optional() const {
  return postinstall_optional_;
}
inline bool PartitionUpdate::postinstall_optional() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.postinstall_optional)
  return _internal_postinstall_optional();
}
inline void PartitionUpdate::_internal_set_postinstall_optional(bool value) {
  _has_bits_[0] |= 0x00008000u;
  postinstall_optional_ = value;
}
inline void PartitionUpdate::set_postinstall_optional(bool value) {
  _internal_set_postinstall_optional(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.postinstall_optional)
}

// optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;
inline bool PartitionUpdate::_internal_has_hash_tree_data_extent() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || hash_tree_data_extent_ != nullptr);
  return value;
}
inline bool PartitionUpdate::has_hash_tree_data_extent() const {
  return _internal_has_hash_tree_data_extent();
}
inline void PartitionUpdate::clear_hash_tree_data_extent() {
  if (hash_tree_data_extent_ != nullptr) hash_tree_data_extent_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::chromeos_update_engine::Extent& PartitionUpdate::_internal_hash_tree_data_extent() const {
  const ::chromeos_update_engine::Extent* p = hash_tree_data_extent_;
  return p != nullptr ? *p : reinterpret_cast<const ::chromeos_update_engine::Extent&>(
      ::chromeos_update_engine::_Extent_default_instance_);
}
inline const ::chromeos_update_engine::Extent& PartitionUpdate::hash_tree_data_extent() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.hash_tree_data_extent)
  return _internal_hash_tree_data_extent();
}
inline void PartitionUpdate::unsafe_arena_set_allocated_hash_tree_data_extent(
    ::chromeos_update_engine::Extent* hash_tree_data_extent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hash_tree_data_extent_);
  }
  hash_tree_data_extent_ = hash_tree_data_extent;
  if (hash_tree_data_extent) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chromeos_update_engine.PartitionUpdate.hash_tree_data_extent)
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::release_hash_tree_data_extent() {
  _has_bits_[0] &= ~0x00000100u;
  ::chromeos_update_engine::Extent* temp = hash_tree_data_extent_;
  hash_tree_data_extent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::unsafe_arena_release_hash_tree_data_extent() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.hash_tree_data_extent)
  _has_bits_[0] &= ~0x00000100u;
  ::chromeos_update_engine::Extent* temp = hash_tree_data_extent_;
  hash_tree_data_extent_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::_internal_mutable_hash_tree_data_extent() {
  _has_bits_[0] |= 0x00000100u;
  if (hash_tree_data_extent_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::Extent>(GetArenaForAllocation());
    hash_tree_data_extent_ = p;
  }
  return hash_tree_data_extent_;
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::mutable_hash_tree_data_extent() {
  ::chromeos_update_engine::Extent* _msg = _internal_mutable_hash_tree_data_extent();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.hash_tree_data_extent)
  return _msg;
}
inline void PartitionUpdate::set_allocated_hash_tree_data_extent(::chromeos_update_engine::Extent* hash_tree_data_extent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete hash_tree_data_extent_;
  }
  if (hash_tree_data_extent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hash_tree_data_extent);
    if (message_arena != submessage_arena) {
      hash_tree_data_extent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hash_tree_data_extent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  hash_tree_data_extent_ = hash_tree_data_extent;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.hash_tree_data_extent)
}

// optional .chromeos_update_engine.Extent hash_tree_extent = 11;
inline bool PartitionUpdate::_internal_has_hash_tree_extent() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || hash_tree_extent_ != nullptr);
  return value;
}
inline bool PartitionUpdate::has_hash_tree_extent() const {
  return _internal_has_hash_tree_extent();
}
inline void PartitionUpdate::clear_hash_tree_extent() {
  if (hash_tree_extent_ != nullptr) hash_tree_extent_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::chromeos_update_engine::Extent& PartitionUpdate::_internal_hash_tree_extent() const {
  const ::chromeos_update_engine::Extent* p = hash_tree_extent_;
  return p != nullptr ? *p : reinterpret_cast<const ::chromeos_update_engine::Extent&>(
      ::chromeos_update_engine::_Extent_default_instance_);
}
inline const ::chromeos_update_engine::Extent& PartitionUpdate::hash_tree_extent() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.hash_tree_extent)
  return _internal_hash_tree_extent();
}
inline void PartitionUpdate::unsafe_arena_set_allocated_hash_tree_extent(
    ::chromeos_update_engine::Extent* hash_tree_extent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hash_tree_extent_);
  }
  hash_tree_extent_ = hash_tree_extent;
  if (hash_tree_extent) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chromeos_update_engine.PartitionUpdate.hash_tree_extent)
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::release_hash_tree_extent() {
  _has_bits_[0] &= ~0x00000200u;
  ::chromeos_update_engine::Extent* temp = hash_tree_extent_;
  hash_tree_extent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::unsafe_arena_release_hash_tree_extent() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.hash_tree_extent)
  _has_bits_[0] &= ~0x00000200u;
  ::chromeos_update_engine::Extent* temp = hash_tree_extent_;
  hash_tree_extent_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::_internal_mutable_hash_tree_extent() {
  _has_bits_[0] |= 0x00000200u;
  if (hash_tree_extent_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::Extent>(GetArenaForAllocation());
    hash_tree_extent_ = p;
  }
  return hash_tree_extent_;
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::mutable_hash_tree_extent() {
  ::chromeos_update_engine::Extent* _msg = _internal_mutable_hash_tree_extent();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.hash_tree_extent)
  return _msg;
}
inline void PartitionUpdate::set_allocated_hash_tree_extent(::chromeos_update_engine::Extent* hash_tree_extent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete hash_tree_extent_;
  }
  if (hash_tree_extent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hash_tree_extent);
    if (message_arena != submessage_arena) {
      hash_tree_extent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hash_tree_extent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  hash_tree_extent_ = hash_tree_extent;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.hash_tree_extent)
}

// optional string hash_tree_algorithm = 12;
inline bool PartitionUpdate::_internal_has_hash_tree_algorithm() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PartitionUpdate::has_hash_tree_algorithm() const {
  return _internal_has_hash_tree_algorithm();
}
inline void PartitionUpdate::clear_hash_tree_algorithm() {
  hash_tree_algorithm_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PartitionUpdate::hash_tree_algorithm() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.hash_tree_algorithm)
  return _internal_hash_tree_algorithm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartitionUpdate::set_hash_tree_algorithm(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 hash_tree_algorithm_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.hash_tree_algorithm)
}
inline std::string* PartitionUpdate::mutable_hash_tree_algorithm() {
  std::string* _s = _internal_mutable_hash_tree_algorithm();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.hash_tree_algorithm)
  return _s;
}
inline const std::string& PartitionUpdate::_internal_hash_tree_algorithm() const {
  return hash_tree_algorithm_.Get();
}
inline void PartitionUpdate::_internal_set_hash_tree_algorithm(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  hash_tree_algorithm_.Set(value, GetArenaForAllocation());
}
inline std::string* PartitionUpdate::_internal_mutable_hash_tree_algorithm() {
  _has_bits_[0] |= 0x00000008u;
  return hash_tree_algorithm_.Mutable(GetArenaForAllocation());
}
inline std::string* PartitionUpdate::release_hash_tree_algorithm() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.hash_tree_algorithm)
  if (!_internal_has_hash_tree_algorithm()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = hash_tree_algorithm_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hash_tree_algorithm_.IsDefault()) {
    hash_tree_algorithm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PartitionUpdate::set_allocated_hash_tree_algorithm(std::string* hash_tree_algorithm) {
  if (hash_tree_algorithm != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  hash_tree_algorithm_.SetAllocated(hash_tree_algorithm, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hash_tree_algorithm_.IsDefault()) {
    hash_tree_algorithm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.hash_tree_algorithm)
}

// optional bytes hash_tree_salt = 13;
inline bool PartitionUpdate::_internal_has_hash_tree_salt() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PartitionUpdate::has_hash_tree_salt() const {
  return _internal_has_hash_tree_salt();
}
inline void PartitionUpdate::clear_hash_tree_salt() {
  hash_tree_salt_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& PartitionUpdate::hash_tree_salt() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.hash_tree_salt)
  return _internal_hash_tree_salt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartitionUpdate::set_hash_tree_salt(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 hash_tree_salt_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.hash_tree_salt)
}
inline std::string* PartitionUpdate::mutable_hash_tree_salt() {
  std::string* _s = _internal_mutable_hash_tree_salt();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.hash_tree_salt)
  return _s;
}
inline const std::string& PartitionUpdate::_internal_hash_tree_salt() const {
  return hash_tree_salt_.Get();
}
inline void PartitionUpdate::_internal_set_hash_tree_salt(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  hash_tree_salt_.Set(value, GetArenaForAllocation());
}
inline std::string* PartitionUpdate::_internal_mutable_hash_tree_salt() {
  _has_bits_[0] |= 0x00000010u;
  return hash_tree_salt_.Mutable(GetArenaForAllocation());
}
inline std::string* PartitionUpdate::release_hash_tree_salt() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.hash_tree_salt)
  if (!_internal_has_hash_tree_salt()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = hash_tree_salt_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hash_tree_salt_.IsDefault()) {
    hash_tree_salt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PartitionUpdate::set_allocated_hash_tree_salt(std::string* hash_tree_salt) {
  if (hash_tree_salt != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  hash_tree_salt_.SetAllocated(hash_tree_salt, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hash_tree_salt_.IsDefault()) {
    hash_tree_salt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.hash_tree_salt)
}

// optional .chromeos_update_engine.Extent fec_data_extent = 14;
inline bool PartitionUpdate::_internal_has_fec_data_extent() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || fec_data_extent_ != nullptr);
  return value;
}
inline bool PartitionUpdate::has_fec_data_extent() const {
  return _internal_has_fec_data_extent();
}
inline void PartitionUpdate::clear_fec_data_extent() {
  if (fec_data_extent_ != nullptr) fec_data_extent_->Clear();
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::chromeos_update_engine::Extent& PartitionUpdate::_internal_fec_data_extent() const {
  const ::chromeos_update_engine::Extent* p = fec_data_extent_;
  return p != nullptr ? *p : reinterpret_cast<const ::chromeos_update_engine::Extent&>(
      ::chromeos_update_engine::_Extent_default_instance_);
}
inline const ::chromeos_update_engine::Extent& PartitionUpdate::fec_data_extent() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.fec_data_extent)
  return _internal_fec_data_extent();
}
inline void PartitionUpdate::unsafe_arena_set_allocated_fec_data_extent(
    ::chromeos_update_engine::Extent* fec_data_extent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fec_data_extent_);
  }
  fec_data_extent_ = fec_data_extent;
  if (fec_data_extent) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chromeos_update_engine.PartitionUpdate.fec_data_extent)
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::release_fec_data_extent() {
  _has_bits_[0] &= ~0x00000400u;
  ::chromeos_update_engine::Extent* temp = fec_data_extent_;
  fec_data_extent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::unsafe_arena_release_fec_data_extent() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.fec_data_extent)
  _has_bits_[0] &= ~0x00000400u;
  ::chromeos_update_engine::Extent* temp = fec_data_extent_;
  fec_data_extent_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::_internal_mutable_fec_data_extent() {
  _has_bits_[0] |= 0x00000400u;
  if (fec_data_extent_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::Extent>(GetArenaForAllocation());
    fec_data_extent_ = p;
  }
  return fec_data_extent_;
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::mutable_fec_data_extent() {
  ::chromeos_update_engine::Extent* _msg = _internal_mutable_fec_data_extent();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.fec_data_extent)
  return _msg;
}
inline void PartitionUpdate::set_allocated_fec_data_extent(::chromeos_update_engine::Extent* fec_data_extent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete fec_data_extent_;
  }
  if (fec_data_extent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fec_data_extent);
    if (message_arena != submessage_arena) {
      fec_data_extent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fec_data_extent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  fec_data_extent_ = fec_data_extent;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.fec_data_extent)
}

// optional .chromeos_update_engine.Extent fec_extent = 15;
inline bool PartitionUpdate::_internal_has_fec_extent() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || fec_extent_ != nullptr);
  return value;
}
inline bool PartitionUpdate::has_fec_extent() const {
  return _internal_has_fec_extent();
}
inline void PartitionUpdate::clear_fec_extent() {
  if (fec_extent_ != nullptr) fec_extent_->Clear();
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::chromeos_update_engine::Extent& PartitionUpdate::_internal_fec_extent() const {
  const ::chromeos_update_engine::Extent* p = fec_extent_;
  return p != nullptr ? *p : reinterpret_cast<const ::chromeos_update_engine::Extent&>(
      ::chromeos_update_engine::_Extent_default_instance_);
}
inline const ::chromeos_update_engine::Extent& PartitionUpdate::fec_extent() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.fec_extent)
  return _internal_fec_extent();
}
inline void PartitionUpdate::unsafe_arena_set_allocated_fec_extent(
    ::chromeos_update_engine::Extent* fec_extent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fec_extent_);
  }
  fec_extent_ = fec_extent;
  if (fec_extent) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chromeos_update_engine.PartitionUpdate.fec_extent)
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::release_fec_extent() {
  _has_bits_[0] &= ~0x00000800u;
  ::chromeos_update_engine::Extent* temp = fec_extent_;
  fec_extent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::unsafe_arena_release_fec_extent() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.fec_extent)
  _has_bits_[0] &= ~0x00000800u;
  ::chromeos_update_engine::Extent* temp = fec_extent_;
  fec_extent_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::_internal_mutable_fec_extent() {
  _has_bits_[0] |= 0x00000800u;
  if (fec_extent_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::Extent>(GetArenaForAllocation());
    fec_extent_ = p;
  }
  return fec_extent_;
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::mutable_fec_extent() {
  ::chromeos_update_engine::Extent* _msg = _internal_mutable_fec_extent();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.fec_extent)
  return _msg;
}
inline void PartitionUpdate::set_allocated_fec_extent(::chromeos_update_engine::Extent* fec_extent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete fec_extent_;
  }
  if (fec_extent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fec_extent);
    if (message_arena != submessage_arena) {
      fec_extent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fec_extent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  fec_extent_ = fec_extent;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.fec_extent)
}

// optional uint32 fec_roots = 16 [default = 2];
inline bool PartitionUpdate::_internal_has_fec_roots() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool PartitionUpdate::has_fec_roots() const {
  return _internal_has_fec_roots();
}
inline void PartitionUpdate::clear_fec_roots() {
  fec_roots_ = 2u;
  _has_bits_[0] &= ~0x00010000u;
}
inline uint32_t PartitionUpdate::_internal_fec_roots() const {
  return fec_roots_;
}
inline uint32_t PartitionUpdate::fec_roots() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.fec_roots)
  return _internal_fec_roots();
}
inline void PartitionUpdate::_internal_set_fec_roots(uint32_t value) {
  _has_bits_[0] |= 0x00010000u;
  fec_roots_ = value;
}
inline void PartitionUpdate::set_fec_roots(uint32_t value) {
  _internal_set_fec_roots(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.fec_roots)
}

// optional string version = 17;
inline bool PartitionUpdate::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PartitionUpdate::has_version() const {
  return _internal_has_version();
}
inline void PartitionUpdate::clear_version() {
  version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& PartitionUpdate::version() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartitionUpdate::set_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.version)
}
inline std::string* PartitionUpdate::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.version)
  return _s;
}
inline const std::string& PartitionUpdate::_internal_version() const {
  return version_.Get();
}
inline void PartitionUpdate::_internal_set_version(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  version_.Set(value, GetArenaForAllocation());
}
inline std::string* PartitionUpdate::_internal_mutable_version() {
  _has_bits_[0] |= 0x00000020u;
  return version_.Mutable(GetArenaForAllocation());
}
inline std::string* PartitionUpdate::release_version() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault()) {
    version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PartitionUpdate::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault()) {
    version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.version)
}

// repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;
inline int PartitionUpdate::_internal_merge_operations_size() const {
  return merge_operations_.size();
}
inline int PartitionUpdate::merge_operations_size() const {
  return _internal_merge_operations_size();
}
inline void PartitionUpdate::clear_merge_operations() {
  merge_operations_.Clear();
}
inline ::chromeos_update_engine::CowMergeOperation* PartitionUpdate::mutable_merge_operations(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.merge_operations)
  return merge_operations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::CowMergeOperation >*
PartitionUpdate::mutable_merge_operations() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.PartitionUpdate.merge_operations)
  return &merge_operations_;
}
inline const ::chromeos_update_engine::CowMergeOperation& PartitionUpdate::_internal_merge_operations(int index) const {
  return merge_operations_.Get(index);
}
inline const ::chromeos_update_engine::CowMergeOperation& PartitionUpdate::merge_operations(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.merge_operations)
  return _internal_merge_operations(index);
}
inline ::chromeos_update_engine::CowMergeOperation* PartitionUpdate::_internal_add_merge_operations() {
  return merge_operations_.Add();
}
inline ::chromeos_update_engine::CowMergeOperation* PartitionUpdate::add_merge_operations() {
  ::chromeos_update_engine::CowMergeOperation* _add = _internal_add_merge_operations();
  // @@protoc_insertion_point(field_add:chromeos_update_engine.PartitionUpdate.merge_operations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::CowMergeOperation >&
PartitionUpdate::merge_operations() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.PartitionUpdate.merge_operations)
  return merge_operations_;
}

// optional uint64 estimate_cow_size = 19;
inline bool PartitionUpdate::_internal_has_estimate_cow_size() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool PartitionUpdate::has_estimate_cow_size() const {
  return _internal_has_estimate_cow_size();
}
inline void PartitionUpdate::clear_estimate_cow_size() {
  estimate_cow_size_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00001000u;
}
inline uint64_t PartitionUpdate::_internal_estimate_cow_size() const {
  return estimate_cow_size_;
}
inline uint64_t PartitionUpdate::estimate_cow_size() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.estimate_cow_size)
  return _internal_estimate_cow_size();
}
inline void PartitionUpdate::_internal_set_estimate_cow_size(uint64_t value) {
  _has_bits_[0] |= 0x00001000u;
  estimate_cow_size_ = value;
}
inline void PartitionUpdate::set_estimate_cow_size(uint64_t value) {
  _internal_set_estimate_cow_size(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.estimate_cow_size)
}

// optional uint64 estimate_op_count_max = 20;
inline bool PartitionUpdate::_internal_has_estimate_op_count_max() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool PartitionUpdate::has_estimate_op_count_max() const {
  return _internal_has_estimate_op_count_max();
}
inline void PartitionUpdate::clear_estimate_op_count_max() {
  estimate_op_count_max_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00002000u;
}
inline uint64_t PartitionUpdate::_internal_estimate_op_count_max() const {
  return estimate_op_count_max_;
}
inline uint64_t PartitionUpdate::estimate_op_count_max() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.estimate_op_count_max)
  return _internal_estimate_op_count_max();
}
inline void PartitionUpdate::_internal_set_estimate_op_count_max(uint64_t value) {
  _has_bits_[0] |= 0x00002000u;
  estimate_op_count_max_ = value;
}
inline void PartitionUpdate::set_estimate_op_count_max(uint64_t value) {
  _internal_set_estimate_op_count_max(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.estimate_op_count_max)
}

// -------------------------------------------------------------------

// DynamicPartitionGroup

// required string name = 1;
inline bool DynamicPartitionGroup::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DynamicPartitionGroup::has_name() const {
  return _internal_has_name();
}
inline void DynamicPartitionGroup::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DynamicPartitionGroup::name() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionGroup.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DynamicPartitionGroup::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DynamicPartitionGroup.name)
}
inline std::string* DynamicPartitionGroup::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DynamicPartitionGroup.name)
  return _s;
}
inline const std::string& DynamicPartitionGroup::_internal_name() const {
  return name_.Get();
}
inline void DynamicPartitionGroup::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* DynamicPartitionGroup::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* DynamicPartitionGroup::release_name() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.DynamicPartitionGroup.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DynamicPartitionGroup::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.DynamicPartitionGroup.name)
}

// optional uint64 size = 2;
inline bool DynamicPartitionGroup::_internal_has_size() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DynamicPartitionGroup::has_size() const {
  return _internal_has_size();
}
inline void DynamicPartitionGroup::clear_size() {
  size_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t DynamicPartitionGroup::_internal_size() const {
  return size_;
}
inline uint64_t DynamicPartitionGroup::size() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionGroup.size)
  return _internal_size();
}
inline void DynamicPartitionGroup::_internal_set_size(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  size_ = value;
}
inline void DynamicPartitionGroup::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DynamicPartitionGroup.size)
}

// repeated string partition_names = 3;
inline int DynamicPartitionGroup::_internal_partition_names_size() const {
  return partition_names_.size();
}
inline int DynamicPartitionGroup::partition_names_size() const {
  return _internal_partition_names_size();
}
inline void DynamicPartitionGroup::clear_partition_names() {
  partition_names_.Clear();
}
inline std::string* DynamicPartitionGroup::add_partition_names() {
  std::string* _s = _internal_add_partition_names();
  // @@protoc_insertion_point(field_add_mutable:chromeos_update_engine.DynamicPartitionGroup.partition_names)
  return _s;
}
inline const std::string& DynamicPartitionGroup::_internal_partition_names(int index) const {
  return partition_names_.Get(index);
}
inline const std::string& DynamicPartitionGroup::partition_names(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionGroup.partition_names)
  return _internal_partition_names(index);
}
inline std::string* DynamicPartitionGroup::mutable_partition_names(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DynamicPartitionGroup.partition_names)
  return partition_names_.Mutable(index);
}
inline void DynamicPartitionGroup::set_partition_names(int index, const std::string& value) {
  partition_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DynamicPartitionGroup.partition_names)
}
inline void DynamicPartitionGroup::set_partition_names(int index, std::string&& value) {
  partition_names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DynamicPartitionGroup.partition_names)
}
inline void DynamicPartitionGroup::set_partition_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  partition_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.DynamicPartitionGroup.partition_names)
}
inline void DynamicPartitionGroup::set_partition_names(int index, const char* value, size_t size) {
  partition_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.DynamicPartitionGroup.partition_names)
}
inline std::string* DynamicPartitionGroup::_internal_add_partition_names() {
  return partition_names_.Add();
}
inline void DynamicPartitionGroup::add_partition_names(const std::string& value) {
  partition_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:chromeos_update_engine.DynamicPartitionGroup.partition_names)
}
inline void DynamicPartitionGroup::add_partition_names(std::string&& value) {
  partition_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:chromeos_update_engine.DynamicPartitionGroup.partition_names)
}
inline void DynamicPartitionGroup::add_partition_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  partition_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:chromeos_update_engine.DynamicPartitionGroup.partition_names)
}
inline void DynamicPartitionGroup::add_partition_names(const char* value, size_t size) {
  partition_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:chromeos_update_engine.DynamicPartitionGroup.partition_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DynamicPartitionGroup::partition_names() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.DynamicPartitionGroup.partition_names)
  return partition_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DynamicPartitionGroup::mutable_partition_names() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.DynamicPartitionGroup.partition_names)
  return &partition_names_;
}

// -------------------------------------------------------------------

// VABCFeatureSet

// optional bool threaded = 1;
inline bool VABCFeatureSet::_internal_has_threaded() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VABCFeatureSet::has_threaded() const {
  return _internal_has_threaded();
}
inline void VABCFeatureSet::clear_threaded() {
  threaded_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool VABCFeatureSet::_internal_threaded() const {
  return threaded_;
}
inline bool VABCFeatureSet::threaded() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.VABCFeatureSet.threaded)
  return _internal_threaded();
}
inline void VABCFeatureSet::_internal_set_threaded(bool value) {
  _has_bits_[0] |= 0x00000001u;
  threaded_ = value;
}
inline void VABCFeatureSet::set_threaded(bool value) {
  _internal_set_threaded(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.VABCFeatureSet.threaded)
}

// optional bool batch_writes = 2;
inline bool VABCFeatureSet::_internal_has_batch_writes() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VABCFeatureSet::has_batch_writes() const {
  return _internal_has_batch_writes();
}
inline void VABCFeatureSet::clear_batch_writes() {
  batch_writes_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool VABCFeatureSet::_internal_batch_writes() const {
  return batch_writes_;
}
inline bool VABCFeatureSet::batch_writes() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.VABCFeatureSet.batch_writes)
  return _internal_batch_writes();
}
inline void VABCFeatureSet::_internal_set_batch_writes(bool value) {
  _has_bits_[0] |= 0x00000002u;
  batch_writes_ = value;
}
inline void VABCFeatureSet::set_batch_writes(bool value) {
  _internal_set_batch_writes(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.VABCFeatureSet.batch_writes)
}

// -------------------------------------------------------------------

// DynamicPartitionMetadata

// repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;
inline int DynamicPartitionMetadata::_internal_groups_size() const {
  return groups_.size();
}
inline int DynamicPartitionMetadata::groups_size() const {
  return _internal_groups_size();
}
inline void DynamicPartitionMetadata::clear_groups() {
  groups_.Clear();
}
inline ::chromeos_update_engine::DynamicPartitionGroup* DynamicPartitionMetadata::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DynamicPartitionMetadata.groups)
  return groups_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::DynamicPartitionGroup >*
DynamicPartitionMetadata::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.DynamicPartitionMetadata.groups)
  return &groups_;
}
inline const ::chromeos_update_engine::DynamicPartitionGroup& DynamicPartitionMetadata::_internal_groups(int index) const {
  return groups_.Get(index);
}
inline const ::chromeos_update_engine::DynamicPartitionGroup& DynamicPartitionMetadata::groups(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionMetadata.groups)
  return _internal_groups(index);
}
inline ::chromeos_update_engine::DynamicPartitionGroup* DynamicPartitionMetadata::_internal_add_groups() {
  return groups_.Add();
}
inline ::chromeos_update_engine::DynamicPartitionGroup* DynamicPartitionMetadata::add_groups() {
  ::chromeos_update_engine::DynamicPartitionGroup* _add = _internal_add_groups();
  // @@protoc_insertion_point(field_add:chromeos_update_engine.DynamicPartitionMetadata.groups)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::DynamicPartitionGroup >&
DynamicPartitionMetadata::groups() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.DynamicPartitionMetadata.groups)
  return groups_;
}

// optional bool snapshot_enabled = 2;
inline bool DynamicPartitionMetadata::_internal_has_snapshot_enabled() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DynamicPartitionMetadata::has_snapshot_enabled() const {
  return _internal_has_snapshot_enabled();
}
inline void DynamicPartitionMetadata::clear_snapshot_enabled() {
  snapshot_enabled_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool DynamicPartitionMetadata::_internal_snapshot_enabled() const {
  return snapshot_enabled_;
}
inline bool DynamicPartitionMetadata::snapshot_enabled() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionMetadata.snapshot_enabled)
  return _internal_snapshot_enabled();
}
inline void DynamicPartitionMetadata::_internal_set_snapshot_enabled(bool value) {
  _has_bits_[0] |= 0x00000004u;
  snapshot_enabled_ = value;
}
inline void DynamicPartitionMetadata::set_snapshot_enabled(bool value) {
  _internal_set_snapshot_enabled(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DynamicPartitionMetadata.snapshot_enabled)
}

// optional bool vabc_enabled = 3;
inline bool DynamicPartitionMetadata::_internal_has_vabc_enabled() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DynamicPartitionMetadata::has_vabc_enabled() const {
  return _internal_has_vabc_enabled();
}
inline void DynamicPartitionMetadata::clear_vabc_enabled() {
  vabc_enabled_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool DynamicPartitionMetadata::_internal_vabc_enabled() const {
  return vabc_enabled_;
}
inline bool DynamicPartitionMetadata::vabc_enabled() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionMetadata.vabc_enabled)
  return _internal_vabc_enabled();
}
inline void DynamicPartitionMetadata::_internal_set_vabc_enabled(bool value) {
  _has_bits_[0] |= 0x00000008u;
  vabc_enabled_ = value;
}
inline void DynamicPartitionMetadata::set_vabc_enabled(bool value) {
  _internal_set_vabc_enabled(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DynamicPartitionMetadata.vabc_enabled)
}

// optional string vabc_compression_param = 4;
inline bool DynamicPartitionMetadata::_internal_has_vabc_compression_param() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DynamicPartitionMetadata::has_vabc_compression_param() const {
  return _internal_has_vabc_compression_param();
}
inline void DynamicPartitionMetadata::clear_vabc_compression_param() {
  vabc_compression_param_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DynamicPartitionMetadata::vabc_compression_param() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionMetadata.vabc_compression_param)
  return _internal_vabc_compression_param();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DynamicPartitionMetadata::set_vabc_compression_param(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 vabc_compression_param_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DynamicPartitionMetadata.vabc_compression_param)
}
inline std::string* DynamicPartitionMetadata::mutable_vabc_compression_param() {
  std::string* _s = _internal_mutable_vabc_compression_param();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DynamicPartitionMetadata.vabc_compression_param)
  return _s;
}
inline const std::string& DynamicPartitionMetadata::_internal_vabc_compression_param() const {
  return vabc_compression_param_.Get();
}
inline void DynamicPartitionMetadata::_internal_set_vabc_compression_param(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  vabc_compression_param_.Set(value, GetArenaForAllocation());
}
inline std::string* DynamicPartitionMetadata::_internal_mutable_vabc_compression_param() {
  _has_bits_[0] |= 0x00000001u;
  return vabc_compression_param_.Mutable(GetArenaForAllocation());
}
inline std::string* DynamicPartitionMetadata::release_vabc_compression_param() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.DynamicPartitionMetadata.vabc_compression_param)
  if (!_internal_has_vabc_compression_param()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = vabc_compression_param_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vabc_compression_param_.IsDefault()) {
    vabc_compression_param_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DynamicPartitionMetadata::set_allocated_vabc_compression_param(std::string* vabc_compression_param) {
  if (vabc_compression_param != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  vabc_compression_param_.SetAllocated(vabc_compression_param, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vabc_compression_param_.IsDefault()) {
    vabc_compression_param_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.DynamicPartitionMetadata.vabc_compression_param)
}

// optional uint32 cow_version = 5;
inline bool DynamicPartitionMetadata::_internal_has_cow_version() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DynamicPartitionMetadata::has_cow_version() const {
  return _internal_has_cow_version();
}
inline void DynamicPartitionMetadata::clear_cow_version() {
  cow_version_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t DynamicPartitionMetadata::_internal_cow_version() const {
  return cow_version_;
}
inline uint32_t DynamicPartitionMetadata::cow_version() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionMetadata.cow_version)
  return _internal_cow_version();
}
inline void DynamicPartitionMetadata::_internal_set_cow_version(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  cow_version_ = value;
}
inline void DynamicPartitionMetadata::set_cow_version(uint32_t value) {
  _internal_set_cow_version(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DynamicPartitionMetadata.cow_version)
}

// optional .chromeos_update_engine.VABCFeatureSet vabc_feature_set = 6;
inline bool DynamicPartitionMetadata::_internal_has_vabc_feature_set() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || vabc_feature_set_ != nullptr);
  return value;
}
inline bool DynamicPartitionMetadata::has_vabc_feature_set() const {
  return _internal_has_vabc_feature_set();
}
inline void DynamicPartitionMetadata::clear_vabc_feature_set() {
  if (vabc_feature_set_ != nullptr) vabc_feature_set_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::chromeos_update_engine::VABCFeatureSet& DynamicPartitionMetadata::_internal_vabc_feature_set() const {
  const ::chromeos_update_engine::VABCFeatureSet* p = vabc_feature_set_;
  return p != nullptr ? *p : reinterpret_cast<const ::chromeos_update_engine::VABCFeatureSet&>(
      ::chromeos_update_engine::_VABCFeatureSet_default_instance_);
}
inline const ::chromeos_update_engine::VABCFeatureSet& DynamicPartitionMetadata::vabc_feature_set() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionMetadata.vabc_feature_set)
  return _internal_vabc_feature_set();
}
inline void DynamicPartitionMetadata::unsafe_arena_set_allocated_vabc_feature_set(
    ::chromeos_update_engine::VABCFeatureSet* vabc_feature_set) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vabc_feature_set_);
  }
  vabc_feature_set_ = vabc_feature_set;
  if (vabc_feature_set) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chromeos_update_engine.DynamicPartitionMetadata.vabc_feature_set)
}
inline ::chromeos_update_engine::VABCFeatureSet* DynamicPartitionMetadata::release_vabc_feature_set() {
  _has_bits_[0] &= ~0x00000002u;
  ::chromeos_update_engine::VABCFeatureSet* temp = vabc_feature_set_;
  vabc_feature_set_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chromeos_update_engine::VABCFeatureSet* DynamicPartitionMetadata::unsafe_arena_release_vabc_feature_set() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.DynamicPartitionMetadata.vabc_feature_set)
  _has_bits_[0] &= ~0x00000002u;
  ::chromeos_update_engine::VABCFeatureSet* temp = vabc_feature_set_;
  vabc_feature_set_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::VABCFeatureSet* DynamicPartitionMetadata::_internal_mutable_vabc_feature_set() {
  _has_bits_[0] |= 0x00000002u;
  if (vabc_feature_set_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::VABCFeatureSet>(GetArenaForAllocation());
    vabc_feature_set_ = p;
  }
  return vabc_feature_set_;
}
inline ::chromeos_update_engine::VABCFeatureSet* DynamicPartitionMetadata::mutable_vabc_feature_set() {
  ::chromeos_update_engine::VABCFeatureSet* _msg = _internal_mutable_vabc_feature_set();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DynamicPartitionMetadata.vabc_feature_set)
  return _msg;
}
inline void DynamicPartitionMetadata::set_allocated_vabc_feature_set(::chromeos_update_engine::VABCFeatureSet* vabc_feature_set) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete vabc_feature_set_;
  }
  if (vabc_feature_set) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vabc_feature_set);
    if (message_arena != submessage_arena) {
      vabc_feature_set = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vabc_feature_set, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  vabc_feature_set_ = vabc_feature_set;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.DynamicPartitionMetadata.vabc_feature_set)
}

// optional uint64 compression_factor = 7;
inline bool DynamicPartitionMetadata::_internal_has_compression_factor() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DynamicPartitionMetadata::has_compression_factor() const {
  return _internal_has_compression_factor();
}
inline void DynamicPartitionMetadata::clear_compression_factor() {
  compression_factor_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000020u;
}
inline uint64_t DynamicPartitionMetadata::_internal_compression_factor() const {
  return compression_factor_;
}
inline uint64_t DynamicPartitionMetadata::compression_factor() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionMetadata.compression_factor)
  return _internal_compression_factor();
}
inline void DynamicPartitionMetadata::_internal_set_compression_factor(uint64_t value) {
  _has_bits_[0] |= 0x00000020u;
  compression_factor_ = value;
}
inline void DynamicPartitionMetadata::set_compression_factor(uint64_t value) {
  _internal_set_compression_factor(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DynamicPartitionMetadata.compression_factor)
}

// -------------------------------------------------------------------

// ApexInfo

// optional string package_name = 1;
inline bool ApexInfo::_internal_has_package_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ApexInfo::has_package_name() const {
  return _internal_has_package_name();
}
inline void ApexInfo::clear_package_name() {
  package_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ApexInfo::package_name() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.ApexInfo.package_name)
  return _internal_package_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApexInfo::set_package_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 package_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chromeos_update_engine.ApexInfo.package_name)
}
inline std::string* ApexInfo::mutable_package_name() {
  std::string* _s = _internal_mutable_package_name();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.ApexInfo.package_name)
  return _s;
}
inline const std::string& ApexInfo::_internal_package_name() const {
  return package_name_.Get();
}
inline void ApexInfo::_internal_set_package_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  package_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ApexInfo::_internal_mutable_package_name() {
  _has_bits_[0] |= 0x00000001u;
  return package_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ApexInfo::release_package_name() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.ApexInfo.package_name)
  if (!_internal_has_package_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = package_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (package_name_.IsDefault()) {
    package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ApexInfo::set_allocated_package_name(std::string* package_name) {
  if (package_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  package_name_.SetAllocated(package_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (package_name_.IsDefault()) {
    package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.ApexInfo.package_name)
}

// optional int64 version = 2;
inline bool ApexInfo::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ApexInfo::has_version() const {
  return _internal_has_version();
}
inline void ApexInfo::clear_version() {
  version_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline int64_t ApexInfo::_internal_version() const {
  return version_;
}
inline int64_t ApexInfo::version() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.ApexInfo.version)
  return _internal_version();
}
inline void ApexInfo::_internal_set_version(int64_t value) {
  _has_bits_[0] |= 0x00000002u;
  version_ = value;
}
inline void ApexInfo::set_version(int64_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.ApexInfo.version)
}

// optional bool is_compressed = 3;
inline bool ApexInfo::_internal_has_is_compressed() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ApexInfo::has_is_compressed() const {
  return _internal_has_is_compressed();
}
inline void ApexInfo::clear_is_compressed() {
  is_compressed_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ApexInfo::_internal_is_compressed() const {
  return is_compressed_;
}
inline bool ApexInfo::is_compressed() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.ApexInfo.is_compressed)
  return _internal_is_compressed();
}
inline void ApexInfo::_internal_set_is_compressed(bool value) {
  _has_bits_[0] |= 0x00000008u;
  is_compressed_ = value;
}
inline void ApexInfo::set_is_compressed(bool value) {
  _internal_set_is_compressed(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.ApexInfo.is_compressed)
}

// optional int64 decompressed_size = 4;
inline bool ApexInfo::_internal_has_decompressed_size() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ApexInfo::has_decompressed_size() const {
  return _internal_has_decompressed_size();
}
inline void ApexInfo::clear_decompressed_size() {
  decompressed_size_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline int64_t ApexInfo::_internal_decompressed_size() const {
  return decompressed_size_;
}
inline int64_t ApexInfo::decompressed_size() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.ApexInfo.decompressed_size)
  return _internal_decompressed_size();
}
inline void ApexInfo::_internal_set_decompressed_size(int64_t value) {
  _has_bits_[0] |= 0x00000004u;
  decompressed_size_ = value;
}
inline void ApexInfo::set_decompressed_size(int64_t value) {
  _internal_set_decompressed_size(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.ApexInfo.decompressed_size)
}

// -------------------------------------------------------------------

// ApexMetadata

// repeated .chromeos_update_engine.ApexInfo apex_info = 1;
inline int ApexMetadata::_internal_apex_info_size() const {
  return apex_info_.size();
}
inline int ApexMetadata::apex_info_size() const {
  return _internal_apex_info_size();
}
inline void ApexMetadata::clear_apex_info() {
  apex_info_.Clear();
}
inline ::chromeos_update_engine::ApexInfo* ApexMetadata::mutable_apex_info(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.ApexMetadata.apex_info)
  return apex_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::ApexInfo >*
ApexMetadata::mutable_apex_info() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.ApexMetadata.apex_info)
  return &apex_info_;
}
inline const ::chromeos_update_engine::ApexInfo& ApexMetadata::_internal_apex_info(int index) const {
  return apex_info_.Get(index);
}
inline const ::chromeos_update_engine::ApexInfo& ApexMetadata::apex_info(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.ApexMetadata.apex_info)
  return _internal_apex_info(index);
}
inline ::chromeos_update_engine::ApexInfo* ApexMetadata::_internal_add_apex_info() {
  return apex_info_.Add();
}
inline ::chromeos_update_engine::ApexInfo* ApexMetadata::add_apex_info() {
  ::chromeos_update_engine::ApexInfo* _add = _internal_add_apex_info();
  // @@protoc_insertion_point(field_add:chromeos_update_engine.ApexMetadata.apex_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::ApexInfo >&
ApexMetadata::apex_info() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.ApexMetadata.apex_info)
  return apex_info_;
}

// -------------------------------------------------------------------

// DeltaArchiveManifest

// optional uint32 block_size = 3 [default = 4096];
inline bool DeltaArchiveManifest::_internal_has_block_size() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool DeltaArchiveManifest::has_block_size() const {
  return _internal_has_block_size();
}
inline void DeltaArchiveManifest::clear_block_size() {
  block_size_ = 4096u;
  _has_bits_[0] &= ~0x00000080u;
}
inline uint32_t DeltaArchiveManifest::_internal_block_size() const {
  return block_size_;
}
inline uint32_t DeltaArchiveManifest::block_size() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.block_size)
  return _internal_block_size();
}
inline void DeltaArchiveManifest::_internal_set_block_size(uint32_t value) {
  _has_bits_[0] |= 0x00000080u;
  block_size_ = value;
}
inline void DeltaArchiveManifest::set_block_size(uint32_t value) {
  _internal_set_block_size(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DeltaArchiveManifest.block_size)
}

// optional uint64 signatures_offset = 4;
inline bool DeltaArchiveManifest::_internal_has_signatures_offset() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DeltaArchiveManifest::has_signatures_offset() const {
  return _internal_has_signatures_offset();
}
inline void DeltaArchiveManifest::clear_signatures_offset() {
  signatures_offset_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t DeltaArchiveManifest::_internal_signatures_offset() const {
  return signatures_offset_;
}
inline uint64_t DeltaArchiveManifest::signatures_offset() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.signatures_offset)
  return _internal_signatures_offset();
}
inline void DeltaArchiveManifest::_internal_set_signatures_offset(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  signatures_offset_ = value;
}
inline void DeltaArchiveManifest::set_signatures_offset(uint64_t value) {
  _internal_set_signatures_offset(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DeltaArchiveManifest.signatures_offset)
}

// optional uint64 signatures_size = 5;
inline bool DeltaArchiveManifest::_internal_has_signatures_size() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DeltaArchiveManifest::has_signatures_size() const {
  return _internal_has_signatures_size();
}
inline void DeltaArchiveManifest::clear_signatures_size() {
  signatures_size_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline uint64_t DeltaArchiveManifest::_internal_signatures_size() const {
  return signatures_size_;
}
inline uint64_t DeltaArchiveManifest::signatures_size() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.signatures_size)
  return _internal_signatures_size();
}
inline void DeltaArchiveManifest::_internal_set_signatures_size(uint64_t value) {
  _has_bits_[0] |= 0x00000008u;
  signatures_size_ = value;
}
inline void DeltaArchiveManifest::set_signatures_size(uint64_t value) {
  _internal_set_signatures_size(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DeltaArchiveManifest.signatures_size)
}

// optional uint32 minor_version = 12 [default = 0];
inline bool DeltaArchiveManifest::_internal_has_minor_version() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DeltaArchiveManifest::has_minor_version() const {
  return _internal_has_minor_version();
}
inline void DeltaArchiveManifest::clear_minor_version() {
  minor_version_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t DeltaArchiveManifest::_internal_minor_version() const {
  return minor_version_;
}
inline uint32_t DeltaArchiveManifest::minor_version() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.minor_version)
  return _internal_minor_version();
}
inline void DeltaArchiveManifest::_internal_set_minor_version(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  minor_version_ = value;
}
inline void DeltaArchiveManifest::set_minor_version(uint32_t value) {
  _internal_set_minor_version(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DeltaArchiveManifest.minor_version)
}

// repeated .chromeos_update_engine.PartitionUpdate partitions = 13;
inline int DeltaArchiveManifest::_internal_partitions_size() const {
  return partitions_.size();
}
inline int DeltaArchiveManifest::partitions_size() const {
  return _internal_partitions_size();
}
inline void DeltaArchiveManifest::clear_partitions() {
  partitions_.Clear();
}
inline ::chromeos_update_engine::PartitionUpdate* DeltaArchiveManifest::mutable_partitions(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DeltaArchiveManifest.partitions)
  return partitions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::PartitionUpdate >*
DeltaArchiveManifest::mutable_partitions() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.DeltaArchiveManifest.partitions)
  return &partitions_;
}
inline const ::chromeos_update_engine::PartitionUpdate& DeltaArchiveManifest::_internal_partitions(int index) const {
  return partitions_.Get(index);
}
inline const ::chromeos_update_engine::PartitionUpdate& DeltaArchiveManifest::partitions(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.partitions)
  return _internal_partitions(index);
}
inline ::chromeos_update_engine::PartitionUpdate* DeltaArchiveManifest::_internal_add_partitions() {
  return partitions_.Add();
}
inline ::chromeos_update_engine::PartitionUpdate* DeltaArchiveManifest::add_partitions() {
  ::chromeos_update_engine::PartitionUpdate* _add = _internal_add_partitions();
  // @@protoc_insertion_point(field_add:chromeos_update_engine.DeltaArchiveManifest.partitions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::PartitionUpdate >&
DeltaArchiveManifest::partitions() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.DeltaArchiveManifest.partitions)
  return partitions_;
}

// optional int64 max_timestamp = 14;
inline bool DeltaArchiveManifest::_internal_has_max_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DeltaArchiveManifest::has_max_timestamp() const {
  return _internal_has_max_timestamp();
}
inline void DeltaArchiveManifest::clear_max_timestamp() {
  max_timestamp_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline int64_t DeltaArchiveManifest::_internal_max_timestamp() const {
  return max_timestamp_;
}
inline int64_t DeltaArchiveManifest::max_timestamp() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.max_timestamp)
  return _internal_max_timestamp();
}
inline void DeltaArchiveManifest::_internal_set_max_timestamp(int64_t value) {
  _has_bits_[0] |= 0x00000010u;
  max_timestamp_ = value;
}
inline void DeltaArchiveManifest::set_max_timestamp(int64_t value) {
  _internal_set_max_timestamp(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DeltaArchiveManifest.max_timestamp)
}

// optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;
inline bool DeltaArchiveManifest::_internal_has_dynamic_partition_metadata() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || dynamic_partition_metadata_ != nullptr);
  return value;
}
inline bool DeltaArchiveManifest::has_dynamic_partition_metadata() const {
  return _internal_has_dynamic_partition_metadata();
}
inline void DeltaArchiveManifest::clear_dynamic_partition_metadata() {
  if (dynamic_partition_metadata_ != nullptr) dynamic_partition_metadata_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::chromeos_update_engine::DynamicPartitionMetadata& DeltaArchiveManifest::_internal_dynamic_partition_metadata() const {
  const ::chromeos_update_engine::DynamicPartitionMetadata* p = dynamic_partition_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::chromeos_update_engine::DynamicPartitionMetadata&>(
      ::chromeos_update_engine::_DynamicPartitionMetadata_default_instance_);
}
inline const ::chromeos_update_engine::DynamicPartitionMetadata& DeltaArchiveManifest::dynamic_partition_metadata() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.dynamic_partition_metadata)
  return _internal_dynamic_partition_metadata();
}
inline void DeltaArchiveManifest::unsafe_arena_set_allocated_dynamic_partition_metadata(
    ::chromeos_update_engine::DynamicPartitionMetadata* dynamic_partition_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dynamic_partition_metadata_);
  }
  dynamic_partition_metadata_ = dynamic_partition_metadata;
  if (dynamic_partition_metadata) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chromeos_update_engine.DeltaArchiveManifest.dynamic_partition_metadata)
}
inline ::chromeos_update_engine::DynamicPartitionMetadata* DeltaArchiveManifest::release_dynamic_partition_metadata() {
  _has_bits_[0] &= ~0x00000002u;
  ::chromeos_update_engine::DynamicPartitionMetadata* temp = dynamic_partition_metadata_;
  dynamic_partition_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chromeos_update_engine::DynamicPartitionMetadata* DeltaArchiveManifest::unsafe_arena_release_dynamic_partition_metadata() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.DeltaArchiveManifest.dynamic_partition_metadata)
  _has_bits_[0] &= ~0x00000002u;
  ::chromeos_update_engine::DynamicPartitionMetadata* temp = dynamic_partition_metadata_;
  dynamic_partition_metadata_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::DynamicPartitionMetadata* DeltaArchiveManifest::_internal_mutable_dynamic_partition_metadata() {
  _has_bits_[0] |= 0x00000002u;
  if (dynamic_partition_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::DynamicPartitionMetadata>(GetArenaForAllocation());
    dynamic_partition_metadata_ = p;
  }
  return dynamic_partition_metadata_;
}
inline ::chromeos_update_engine::DynamicPartitionMetadata* DeltaArchiveManifest::mutable_dynamic_partition_metadata() {
  ::chromeos_update_engine::DynamicPartitionMetadata* _msg = _internal_mutable_dynamic_partition_metadata();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DeltaArchiveManifest.dynamic_partition_metadata)
  return _msg;
}
inline void DeltaArchiveManifest::set_allocated_dynamic_partition_metadata(::chromeos_update_engine::DynamicPartitionMetadata* dynamic_partition_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dynamic_partition_metadata_;
  }
  if (dynamic_partition_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dynamic_partition_metadata);
    if (message_arena != submessage_arena) {
      dynamic_partition_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dynamic_partition_metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  dynamic_partition_metadata_ = dynamic_partition_metadata;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.DeltaArchiveManifest.dynamic_partition_metadata)
}

// optional bool partial_update = 16;
inline bool DeltaArchiveManifest::_internal_has_partial_update() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DeltaArchiveManifest::has_partial_update() const {
  return _internal_has_partial_update();
}
inline void DeltaArchiveManifest::clear_partial_update() {
  partial_update_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool DeltaArchiveManifest::_internal_partial_update() const {
  return partial_update_;
}
inline bool DeltaArchiveManifest::partial_update() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.partial_update)
  return _internal_partial_update();
}
inline void DeltaArchiveManifest::_internal_set_partial_update(bool value) {
  _has_bits_[0] |= 0x00000040u;
  partial_update_ = value;
}
inline void DeltaArchiveManifest::set_partial_update(bool value) {
  _internal_set_partial_update(value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DeltaArchiveManifest.partial_update)
}

// repeated .chromeos_update_engine.ApexInfo apex_info = 17;
inline int DeltaArchiveManifest::_internal_apex_info_size() const {
  return apex_info_.size();
}
inline int DeltaArchiveManifest::apex_info_size() const {
  return _internal_apex_info_size();
}
inline void DeltaArchiveManifest::clear_apex_info() {
  apex_info_.Clear();
}
inline ::chromeos_update_engine::ApexInfo* DeltaArchiveManifest::mutable_apex_info(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DeltaArchiveManifest.apex_info)
  return apex_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::ApexInfo >*
DeltaArchiveManifest::mutable_apex_info() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.DeltaArchiveManifest.apex_info)
  return &apex_info_;
}
inline const ::chromeos_update_engine::ApexInfo& DeltaArchiveManifest::_internal_apex_info(int index) const {
  return apex_info_.Get(index);
}
inline const ::chromeos_update_engine::ApexInfo& DeltaArchiveManifest::apex_info(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.apex_info)
  return _internal_apex_info(index);
}
inline ::chromeos_update_engine::ApexInfo* DeltaArchiveManifest::_internal_add_apex_info() {
  return apex_info_.Add();
}
inline ::chromeos_update_engine::ApexInfo* DeltaArchiveManifest::add_apex_info() {
  ::chromeos_update_engine::ApexInfo* _add = _internal_add_apex_info();
  // @@protoc_insertion_point(field_add:chromeos_update_engine.DeltaArchiveManifest.apex_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chromeos_update_engine::ApexInfo >&
DeltaArchiveManifest::apex_info() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.DeltaArchiveManifest.apex_info)
  return apex_info_;
}

// optional string security_patch_level = 18;
inline bool DeltaArchiveManifest::_internal_has_security_patch_level() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeltaArchiveManifest::has_security_patch_level() const {
  return _internal_has_security_patch_level();
}
inline void DeltaArchiveManifest::clear_security_patch_level() {
  security_patch_level_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeltaArchiveManifest::security_patch_level() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.security_patch_level)
  return _internal_security_patch_level();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeltaArchiveManifest::set_security_patch_level(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 security_patch_level_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DeltaArchiveManifest.security_patch_level)
}
inline std::string* DeltaArchiveManifest::mutable_security_patch_level() {
  std::string* _s = _internal_mutable_security_patch_level();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DeltaArchiveManifest.security_patch_level)
  return _s;
}
inline const std::string& DeltaArchiveManifest::_internal_security_patch_level() const {
  return security_patch_level_.Get();
}
inline void DeltaArchiveManifest::_internal_set_security_patch_level(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  security_patch_level_.Set(value, GetArenaForAllocation());
}
inline std::string* DeltaArchiveManifest::_internal_mutable_security_patch_level() {
  _has_bits_[0] |= 0x00000001u;
  return security_patch_level_.Mutable(GetArenaForAllocation());
}
inline std::string* DeltaArchiveManifest::release_security_patch_level() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.DeltaArchiveManifest.security_patch_level)
  if (!_internal_has_security_patch_level()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = security_patch_level_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (security_patch_level_.IsDefault()) {
    security_patch_level_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeltaArchiveManifest::set_allocated_security_patch_level(std::string* security_patch_level) {
  if (security_patch_level != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  security_patch_level_.SetAllocated(security_patch_level, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (security_patch_level_.IsDefault()) {
    security_patch_level_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.DeltaArchiveManifest.security_patch_level)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace chromeos_update_engine

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::chromeos_update_engine::InstallOperation_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::chromeos_update_engine::InstallOperation_Type>() {
  return ::chromeos_update_engine::InstallOperation_Type_descriptor();
}
template <> struct is_proto_enum< ::chromeos_update_engine::CowMergeOperation_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::chromeos_update_engine::CowMergeOperation_Type>() {
  return ::chromeos_update_engine::CowMergeOperation_Type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_update_5fmetadata_2eproto
